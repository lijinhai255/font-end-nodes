<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试小册子 | 前端总结</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="大前端课程电子书">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/font-end-nodes/assets/css/0.styles.038bd01d.css" as="style"><link rel="preload" href="/font-end-nodes/assets/js/app.832bd39e.js" as="script"><link rel="preload" href="/font-end-nodes/assets/js/2.a07749b4.js" as="script"><link rel="preload" href="/font-end-nodes/assets/js/1.80701c87.js" as="script"><link rel="preload" href="/font-end-nodes/assets/js/232.24744b96.js" as="script"><link rel="prefetch" href="/font-end-nodes/assets/js/10.5638679e.js"><link rel="prefetch" href="/font-end-nodes/assets/js/100.bbb244c0.js"><link rel="prefetch" href="/font-end-nodes/assets/js/101.9bcb852f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/102.8dbea368.js"><link rel="prefetch" href="/font-end-nodes/assets/js/103.092e8ed9.js"><link rel="prefetch" href="/font-end-nodes/assets/js/104.f4591300.js"><link rel="prefetch" href="/font-end-nodes/assets/js/105.fc42a7e9.js"><link rel="prefetch" href="/font-end-nodes/assets/js/106.24d25138.js"><link rel="prefetch" href="/font-end-nodes/assets/js/107.f1e82fff.js"><link rel="prefetch" href="/font-end-nodes/assets/js/108.5bf31ec8.js"><link rel="prefetch" href="/font-end-nodes/assets/js/109.6b14a562.js"><link rel="prefetch" href="/font-end-nodes/assets/js/11.a98b3d1b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/110.ca51e272.js"><link rel="prefetch" href="/font-end-nodes/assets/js/111.8036b121.js"><link rel="prefetch" href="/font-end-nodes/assets/js/112.8f521968.js"><link rel="prefetch" href="/font-end-nodes/assets/js/113.1aaf7230.js"><link rel="prefetch" href="/font-end-nodes/assets/js/114.8a58b5f0.js"><link rel="prefetch" href="/font-end-nodes/assets/js/115.4a4b0a5a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/116.e2c0fc24.js"><link rel="prefetch" href="/font-end-nodes/assets/js/117.7f08754c.js"><link rel="prefetch" href="/font-end-nodes/assets/js/118.53a69f97.js"><link rel="prefetch" href="/font-end-nodes/assets/js/119.32039f41.js"><link rel="prefetch" href="/font-end-nodes/assets/js/12.f77a1598.js"><link rel="prefetch" href="/font-end-nodes/assets/js/120.fe9d4157.js"><link rel="prefetch" href="/font-end-nodes/assets/js/121.5059caa6.js"><link rel="prefetch" href="/font-end-nodes/assets/js/122.93e4f4e0.js"><link rel="prefetch" href="/font-end-nodes/assets/js/123.0427d914.js"><link rel="prefetch" href="/font-end-nodes/assets/js/124.fb5db03b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/125.eff72124.js"><link rel="prefetch" href="/font-end-nodes/assets/js/126.5071d677.js"><link rel="prefetch" href="/font-end-nodes/assets/js/127.b3c4b7ca.js"><link rel="prefetch" href="/font-end-nodes/assets/js/128.2ef02a49.js"><link rel="prefetch" href="/font-end-nodes/assets/js/129.3310c25b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/13.28e817ab.js"><link rel="prefetch" href="/font-end-nodes/assets/js/130.dd442d73.js"><link rel="prefetch" href="/font-end-nodes/assets/js/131.02f4f1ed.js"><link rel="prefetch" href="/font-end-nodes/assets/js/132.75abe376.js"><link rel="prefetch" href="/font-end-nodes/assets/js/133.b4cd450b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/134.773213fa.js"><link rel="prefetch" href="/font-end-nodes/assets/js/135.05acfff1.js"><link rel="prefetch" href="/font-end-nodes/assets/js/136.561a96e3.js"><link rel="prefetch" href="/font-end-nodes/assets/js/137.fc29b321.js"><link rel="prefetch" href="/font-end-nodes/assets/js/138.6a94f8cc.js"><link rel="prefetch" href="/font-end-nodes/assets/js/139.8e167778.js"><link rel="prefetch" href="/font-end-nodes/assets/js/14.24b2d1e9.js"><link rel="prefetch" href="/font-end-nodes/assets/js/140.a54c24f6.js"><link rel="prefetch" href="/font-end-nodes/assets/js/141.194fcb5f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/142.3274c5e9.js"><link rel="prefetch" href="/font-end-nodes/assets/js/143.ec0a823c.js"><link rel="prefetch" href="/font-end-nodes/assets/js/144.3ea73463.js"><link rel="prefetch" href="/font-end-nodes/assets/js/145.bb844e22.js"><link rel="prefetch" href="/font-end-nodes/assets/js/146.7da8e190.js"><link rel="prefetch" href="/font-end-nodes/assets/js/147.b412d59a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/148.cd0ec593.js"><link rel="prefetch" href="/font-end-nodes/assets/js/149.1f758e6c.js"><link rel="prefetch" href="/font-end-nodes/assets/js/15.b5a6e3a7.js"><link rel="prefetch" href="/font-end-nodes/assets/js/150.6e84f5f3.js"><link rel="prefetch" href="/font-end-nodes/assets/js/151.a34b1a26.js"><link rel="prefetch" href="/font-end-nodes/assets/js/152.db2842b1.js"><link rel="prefetch" href="/font-end-nodes/assets/js/153.f6a16ff9.js"><link rel="prefetch" href="/font-end-nodes/assets/js/154.62fd3be8.js"><link rel="prefetch" href="/font-end-nodes/assets/js/155.fd3625d1.js"><link rel="prefetch" href="/font-end-nodes/assets/js/156.898c1c8b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/157.ccffe0db.js"><link rel="prefetch" href="/font-end-nodes/assets/js/158.7baa1f54.js"><link rel="prefetch" href="/font-end-nodes/assets/js/159.e751bb95.js"><link rel="prefetch" href="/font-end-nodes/assets/js/16.a6d304c0.js"><link rel="prefetch" href="/font-end-nodes/assets/js/160.8a5bab47.js"><link rel="prefetch" href="/font-end-nodes/assets/js/161.db66d218.js"><link rel="prefetch" href="/font-end-nodes/assets/js/162.0299c78c.js"><link rel="prefetch" href="/font-end-nodes/assets/js/163.81d4d2cd.js"><link rel="prefetch" href="/font-end-nodes/assets/js/164.edab15cc.js"><link rel="prefetch" href="/font-end-nodes/assets/js/165.06fb1c70.js"><link rel="prefetch" href="/font-end-nodes/assets/js/166.003fb882.js"><link rel="prefetch" href="/font-end-nodes/assets/js/167.fae77e3f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/168.7c5a932e.js"><link rel="prefetch" href="/font-end-nodes/assets/js/169.42c12bb0.js"><link rel="prefetch" href="/font-end-nodes/assets/js/17.bc3513cf.js"><link rel="prefetch" href="/font-end-nodes/assets/js/170.80bdfb2e.js"><link rel="prefetch" href="/font-end-nodes/assets/js/171.0cd4762d.js"><link rel="prefetch" href="/font-end-nodes/assets/js/172.e9c9c9ff.js"><link rel="prefetch" href="/font-end-nodes/assets/js/173.55b6a562.js"><link rel="prefetch" href="/font-end-nodes/assets/js/174.332f7641.js"><link rel="prefetch" href="/font-end-nodes/assets/js/175.ac667b47.js"><link rel="prefetch" href="/font-end-nodes/assets/js/176.9c953fb8.js"><link rel="prefetch" href="/font-end-nodes/assets/js/177.09cb3caa.js"><link rel="prefetch" href="/font-end-nodes/assets/js/178.3b16f68c.js"><link rel="prefetch" href="/font-end-nodes/assets/js/179.b68e7c4a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/18.9ffcf5fe.js"><link rel="prefetch" href="/font-end-nodes/assets/js/180.8c7ba5fc.js"><link rel="prefetch" href="/font-end-nodes/assets/js/181.918fb497.js"><link rel="prefetch" href="/font-end-nodes/assets/js/182.55c29c82.js"><link rel="prefetch" href="/font-end-nodes/assets/js/183.d17aba41.js"><link rel="prefetch" href="/font-end-nodes/assets/js/184.2ef0b515.js"><link rel="prefetch" href="/font-end-nodes/assets/js/185.cb70f352.js"><link rel="prefetch" href="/font-end-nodes/assets/js/186.db8f35ad.js"><link rel="prefetch" href="/font-end-nodes/assets/js/187.01cad883.js"><link rel="prefetch" href="/font-end-nodes/assets/js/188.bbc4b58b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/189.a725e800.js"><link rel="prefetch" href="/font-end-nodes/assets/js/19.3bb95980.js"><link rel="prefetch" href="/font-end-nodes/assets/js/190.57b6c7af.js"><link rel="prefetch" href="/font-end-nodes/assets/js/191.5317b26c.js"><link rel="prefetch" href="/font-end-nodes/assets/js/192.1957e20b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/193.1f8a87e4.js"><link rel="prefetch" href="/font-end-nodes/assets/js/194.709ef4a8.js"><link rel="prefetch" href="/font-end-nodes/assets/js/195.89d53a46.js"><link rel="prefetch" href="/font-end-nodes/assets/js/196.deb26b2a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/197.91768f16.js"><link rel="prefetch" href="/font-end-nodes/assets/js/198.262d7de3.js"><link rel="prefetch" href="/font-end-nodes/assets/js/199.c72a561f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/20.b48aca0a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/200.70ae2a60.js"><link rel="prefetch" href="/font-end-nodes/assets/js/201.1c603d87.js"><link rel="prefetch" href="/font-end-nodes/assets/js/202.236c927e.js"><link rel="prefetch" href="/font-end-nodes/assets/js/203.b521acdf.js"><link rel="prefetch" href="/font-end-nodes/assets/js/204.ea7aa51f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/205.30a1c9f5.js"><link rel="prefetch" href="/font-end-nodes/assets/js/206.06ae9af3.js"><link rel="prefetch" href="/font-end-nodes/assets/js/207.1c669711.js"><link rel="prefetch" href="/font-end-nodes/assets/js/208.74d55e9a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/209.20a64f5d.js"><link rel="prefetch" href="/font-end-nodes/assets/js/21.43407cf9.js"><link rel="prefetch" href="/font-end-nodes/assets/js/210.8123de01.js"><link rel="prefetch" href="/font-end-nodes/assets/js/211.b66cbd60.js"><link rel="prefetch" href="/font-end-nodes/assets/js/212.c679bf00.js"><link rel="prefetch" href="/font-end-nodes/assets/js/213.a74b7820.js"><link rel="prefetch" href="/font-end-nodes/assets/js/214.828ea554.js"><link rel="prefetch" href="/font-end-nodes/assets/js/215.7786d3de.js"><link rel="prefetch" href="/font-end-nodes/assets/js/216.51c1c323.js"><link rel="prefetch" href="/font-end-nodes/assets/js/217.65f8b41e.js"><link rel="prefetch" href="/font-end-nodes/assets/js/218.c9df38de.js"><link rel="prefetch" href="/font-end-nodes/assets/js/219.b351dd6e.js"><link rel="prefetch" href="/font-end-nodes/assets/js/22.19dadf3b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/220.39ab9705.js"><link rel="prefetch" href="/font-end-nodes/assets/js/221.8ebbb74a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/222.e2deb206.js"><link rel="prefetch" href="/font-end-nodes/assets/js/223.e2fcb32b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/224.ffaedba7.js"><link rel="prefetch" href="/font-end-nodes/assets/js/225.b58f86d9.js"><link rel="prefetch" href="/font-end-nodes/assets/js/226.399be9a7.js"><link rel="prefetch" href="/font-end-nodes/assets/js/227.b51cf204.js"><link rel="prefetch" href="/font-end-nodes/assets/js/228.5009fc56.js"><link rel="prefetch" href="/font-end-nodes/assets/js/229.de5b340a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/23.d3c67335.js"><link rel="prefetch" href="/font-end-nodes/assets/js/230.98d2e2f2.js"><link rel="prefetch" href="/font-end-nodes/assets/js/231.4fcae33b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/233.0b4d75ba.js"><link rel="prefetch" href="/font-end-nodes/assets/js/234.888f6bf1.js"><link rel="prefetch" href="/font-end-nodes/assets/js/235.21961b6f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/236.0f0c8301.js"><link rel="prefetch" href="/font-end-nodes/assets/js/237.7a097607.js"><link rel="prefetch" href="/font-end-nodes/assets/js/238.d8198c48.js"><link rel="prefetch" href="/font-end-nodes/assets/js/239.f19c451d.js"><link rel="prefetch" href="/font-end-nodes/assets/js/24.4f542f6f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/240.1ca90350.js"><link rel="prefetch" href="/font-end-nodes/assets/js/241.0bf3cab7.js"><link rel="prefetch" href="/font-end-nodes/assets/js/242.e498cedc.js"><link rel="prefetch" href="/font-end-nodes/assets/js/243.03b956d7.js"><link rel="prefetch" href="/font-end-nodes/assets/js/244.558b6e6b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/245.5d6f4ee0.js"><link rel="prefetch" href="/font-end-nodes/assets/js/246.b260c5c2.js"><link rel="prefetch" href="/font-end-nodes/assets/js/247.beb18cd0.js"><link rel="prefetch" href="/font-end-nodes/assets/js/248.719ed8b8.js"><link rel="prefetch" href="/font-end-nodes/assets/js/249.1d0b4bf4.js"><link rel="prefetch" href="/font-end-nodes/assets/js/25.413ebcc0.js"><link rel="prefetch" href="/font-end-nodes/assets/js/250.323c5592.js"><link rel="prefetch" href="/font-end-nodes/assets/js/251.5afad404.js"><link rel="prefetch" href="/font-end-nodes/assets/js/252.55fed331.js"><link rel="prefetch" href="/font-end-nodes/assets/js/253.827806ad.js"><link rel="prefetch" href="/font-end-nodes/assets/js/254.a88e257f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/255.ad4d0c32.js"><link rel="prefetch" href="/font-end-nodes/assets/js/26.2ef11f46.js"><link rel="prefetch" href="/font-end-nodes/assets/js/27.1ac063f4.js"><link rel="prefetch" href="/font-end-nodes/assets/js/28.0176bc33.js"><link rel="prefetch" href="/font-end-nodes/assets/js/29.f051ed2a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/3.3438f0f2.js"><link rel="prefetch" href="/font-end-nodes/assets/js/30.14ff7587.js"><link rel="prefetch" href="/font-end-nodes/assets/js/31.2e4c2658.js"><link rel="prefetch" href="/font-end-nodes/assets/js/32.7bcd76e7.js"><link rel="prefetch" href="/font-end-nodes/assets/js/33.b5ea4703.js"><link rel="prefetch" href="/font-end-nodes/assets/js/34.4a59e1b2.js"><link rel="prefetch" href="/font-end-nodes/assets/js/35.9ed9d4ab.js"><link rel="prefetch" href="/font-end-nodes/assets/js/36.682e318e.js"><link rel="prefetch" href="/font-end-nodes/assets/js/37.7494daaa.js"><link rel="prefetch" href="/font-end-nodes/assets/js/38.b5cd0d3b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/39.af0496cd.js"><link rel="prefetch" href="/font-end-nodes/assets/js/4.7a5e1a1f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/40.14476c01.js"><link rel="prefetch" href="/font-end-nodes/assets/js/41.8bc5761f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/42.7aa4d4c4.js"><link rel="prefetch" href="/font-end-nodes/assets/js/43.62e2cdce.js"><link rel="prefetch" href="/font-end-nodes/assets/js/44.a1c3cc89.js"><link rel="prefetch" href="/font-end-nodes/assets/js/45.4fe7d8fb.js"><link rel="prefetch" href="/font-end-nodes/assets/js/46.6ab93663.js"><link rel="prefetch" href="/font-end-nodes/assets/js/47.a9584d0e.js"><link rel="prefetch" href="/font-end-nodes/assets/js/48.4d783f78.js"><link rel="prefetch" href="/font-end-nodes/assets/js/49.08e03685.js"><link rel="prefetch" href="/font-end-nodes/assets/js/5.9263c847.js"><link rel="prefetch" href="/font-end-nodes/assets/js/50.236470a2.js"><link rel="prefetch" href="/font-end-nodes/assets/js/51.48a95f65.js"><link rel="prefetch" href="/font-end-nodes/assets/js/52.aefd198b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/53.10124fe3.js"><link rel="prefetch" href="/font-end-nodes/assets/js/54.7f193a2a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/55.8b6083af.js"><link rel="prefetch" href="/font-end-nodes/assets/js/56.c4735383.js"><link rel="prefetch" href="/font-end-nodes/assets/js/57.bcce1b46.js"><link rel="prefetch" href="/font-end-nodes/assets/js/58.d706164d.js"><link rel="prefetch" href="/font-end-nodes/assets/js/59.3d4b6637.js"><link rel="prefetch" href="/font-end-nodes/assets/js/6.1087f0eb.js"><link rel="prefetch" href="/font-end-nodes/assets/js/60.eaeb39ae.js"><link rel="prefetch" href="/font-end-nodes/assets/js/61.d29c232a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/62.0d9b1632.js"><link rel="prefetch" href="/font-end-nodes/assets/js/63.b7b031f3.js"><link rel="prefetch" href="/font-end-nodes/assets/js/64.327ec6ab.js"><link rel="prefetch" href="/font-end-nodes/assets/js/65.7260dd4f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/66.89326128.js"><link rel="prefetch" href="/font-end-nodes/assets/js/67.c6db4c2f.js"><link rel="prefetch" href="/font-end-nodes/assets/js/68.c57a211e.js"><link rel="prefetch" href="/font-end-nodes/assets/js/69.a18c29e4.js"><link rel="prefetch" href="/font-end-nodes/assets/js/7.072b61fc.js"><link rel="prefetch" href="/font-end-nodes/assets/js/70.830c1fb2.js"><link rel="prefetch" href="/font-end-nodes/assets/js/71.8b0a8d85.js"><link rel="prefetch" href="/font-end-nodes/assets/js/72.cfe385d0.js"><link rel="prefetch" href="/font-end-nodes/assets/js/73.1f040d65.js"><link rel="prefetch" href="/font-end-nodes/assets/js/74.abc17026.js"><link rel="prefetch" href="/font-end-nodes/assets/js/75.48d766fe.js"><link rel="prefetch" href="/font-end-nodes/assets/js/76.309c6949.js"><link rel="prefetch" href="/font-end-nodes/assets/js/77.72d9f7a8.js"><link rel="prefetch" href="/font-end-nodes/assets/js/78.ff5bc9e8.js"><link rel="prefetch" href="/font-end-nodes/assets/js/79.59c5403e.js"><link rel="prefetch" href="/font-end-nodes/assets/js/80.1d2f49d1.js"><link rel="prefetch" href="/font-end-nodes/assets/js/81.c479157a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/82.2a333eee.js"><link rel="prefetch" href="/font-end-nodes/assets/js/83.3a7be879.js"><link rel="prefetch" href="/font-end-nodes/assets/js/84.6d0d2b22.js"><link rel="prefetch" href="/font-end-nodes/assets/js/85.7e519f88.js"><link rel="prefetch" href="/font-end-nodes/assets/js/86.b82ff84b.js"><link rel="prefetch" href="/font-end-nodes/assets/js/87.9287a7fb.js"><link rel="prefetch" href="/font-end-nodes/assets/js/88.dea748dd.js"><link rel="prefetch" href="/font-end-nodes/assets/js/89.496fa253.js"><link rel="prefetch" href="/font-end-nodes/assets/js/90.07bc942e.js"><link rel="prefetch" href="/font-end-nodes/assets/js/91.03e65ea9.js"><link rel="prefetch" href="/font-end-nodes/assets/js/92.c58a7599.js"><link rel="prefetch" href="/font-end-nodes/assets/js/93.67e7d7f3.js"><link rel="prefetch" href="/font-end-nodes/assets/js/94.4a225295.js"><link rel="prefetch" href="/font-end-nodes/assets/js/95.a2616bcc.js"><link rel="prefetch" href="/font-end-nodes/assets/js/96.539d9eff.js"><link rel="prefetch" href="/font-end-nodes/assets/js/97.601ed07a.js"><link rel="prefetch" href="/font-end-nodes/assets/js/98.f4239bf1.js"><link rel="prefetch" href="/font-end-nodes/assets/js/99.c3c3e670.js"><link rel="prefetch" href="/font-end-nodes/assets/js/vendors~docsearch.6cf52aa5.js">
    <link rel="stylesheet" href="/font-end-nodes/assets/css/0.styles.038bd01d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/font-end-nodes/" class="home-link router-link-active"><!----> <span class="site-name">前端总结</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端面试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/font-end-nodes/interview/types/" aria-current="page" class="sidebar-link">分类题</a></li><li><a href="/font-end-nodes/interview/types/01-vue2.html" class="sidebar-link">Vue2</a></li><li><a href="/font-end-nodes/interview/types/02-vue3.html" class="sidebar-link">Vue3</a></li><li><a href="/font-end-nodes/interview/types/03-React17.html" class="sidebar-link">React17</a></li><li><a href="/font-end-nodes/interview/types/04-Webpack.html" class="sidebar-link">webpack</a></li><li><a href="/font-end-nodes/interview/types/05-数据结构和算法.html" class="sidebar-link">数据结构和算法</a></li><li><a href="/font-end-nodes/interview/types/06-js基础部分.html" class="sidebar-link">js基础部分</a></li><li><a href="/font-end-nodes/interview/types/07-性能优化.html" class="sidebar-link">性能优化</a></li><li><a href="/font-end-nodes/interview/types/08-问题总结.html" class="sidebar-link">问题总结</a></li><li><a href="/font-end-nodes/interview/types/09-http的那些事.html" class="sidebar-link">https协议那些事</a></li><li><a href="/font-end-nodes/interview/types/10.数据结构与算法.html" class="sidebar-link">数据与算法结构概论</a></li><li><a href="/font-end-nodes/interview/types/11-React核心技术点.html" class="sidebar-link">React 原理核心技术点</a></li><li><a href="/font-end-nodes/interview/types/12-从0实现react16源码.html" class="sidebar-link">从0实现React16源码</a></li><li><a href="/font-end-nodes/interview/types/13-React17与React18的更新变化.html" class="sidebar-link">React17与React18的更新变化</a></li><li><a href="/font-end-nodes/interview/types/14-react18源码核心细节.html" class="sidebar-link">React 18 源码核心流程</a></li><li><a href="/font-end-nodes/interview/types/15-vue设计原理.html" class="sidebar-link">vue 设计原理</a></li><li><a href="/font-end-nodes/interview/types/16-webpack核心原理.html" class="sidebar-link">webpack 核心原理</a></li><li><a href="/font-end-nodes/interview/types/17-手写Redux和Vuex.html" class="sidebar-link">手写Redux和Vuex</a></li><li><a href="/font-end-nodes/interview/types/18.手写Recoil.html" class="sidebar-link">手写Recoil</a></li><li><a href="/font-end-nodes/interview/types/19.webpack优化.html" class="sidebar-link">webpack 优化 SplitChunks 分包</a></li><li><a href="/font-end-nodes/interview/types/20.使用TS实现性能监控.html" class="sidebar-link">使用TS从0实战性能监控SDK</a></li><li><a href="/font-end-nodes/interview/types/21-http哪些事.html" class="sidebar-link">Http哪些事</a></li><li><a href="/font-end-nodes/interview/types/22-html和css.html" class="sidebar-link">Html和CSS</a></li><li><a href="/font-end-nodes/interview/types/23-js.html" class="sidebar-link">堆和栈</a></li><li><a href="/font-end-nodes/interview/types/24-interview-1.html" class="sidebar-link">前端架构方向</a></li><li><a href="/font-end-nodes/interview/types/25-面试小册子.html" class="sidebar-link">前端面试小册子</a></li><li><a href="/font-end-nodes/interview/types/26-自定义SSR.html" class="sidebar-link">自定义SSR</a></li><li><a href="/font-end-nodes/interview/types/27-面试小册子.html" class="active sidebar-link">前端面试小册子</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react15-161718都有愿些新变化" class="sidebar-link">React15/161718都有愿些新变化？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-版本对比" class="sidebar-link">React 版本对比</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#top-level-await" class="sidebar-link">top-level await</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-中的-use-使用指南" class="sidebar-link">React 中的 use 使用指南</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-19-中的-formstate-和-formaction" class="sidebar-link">React 19 中的 formState 和 formAction</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#它们是否是-react-19-的新特性" class="sidebar-link">它们是否是 React 19 的新特性？</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#formstate-的作用" class="sidebar-link">`formState` 的作用</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#usetransition是提解决了什么-解决了什么" class="sidebar-link">useTransition是提解决了什么？ 解决了什么？</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#作用" class="sidebar-link">作用</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#语法" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#用法示例" class="sidebar-link">用法示例</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_1-基本示例-处理输入和过滤列表" class="sidebar-link">1. 基本示例：处理输入和过滤列表</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_2-优化繁重任务的用户体验" class="sidebar-link">2. 优化繁重任务的用户体验</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_3-动态渲染分页列表" class="sidebar-link">3. 动态渲染分页列表</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#注意事项" class="sidebar-link">注意事项</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#简介-2" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_1-usetransition" class="sidebar-link">1. `useTransition`</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#核心概念" class="sidebar-link">核心概念</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#语法-2" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#使用场景" class="sidebar-link">使用场景</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#示例-2" class="sidebar-link">示例</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_2-usedeferredvalue" class="sidebar-link">2. `useDeferredValue`</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#核心概念-2" class="sidebar-link">核心概念</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#语法-3" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#使用场景-2" class="sidebar-link">使用场景</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#示例-3" class="sidebar-link">示例</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#对比总结" class="sidebar-link">对比总结</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#使用建议" class="sidebar-link">使用建议</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#总结-2" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react整体渲染流程请描述下-。那你能说下双缓存是在哪个阶段设置的么-优缺点是什么" class="sidebar-link">React整体渲染流程请描述下？ 。那你能说下双缓存是在哪个阶段设置的么？优缺点是什么？</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#fiber架构原理你能细致描达下么" class="sidebar-link">Fiber架构原理你能细致描达下么？</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-fiber-核心概念和原理" class="sidebar-link">React Fiber 核心概念和原理</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#fiber-是什么" class="sidebar-link">Fiber 是什么？</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#fiber-核心原理的几个关键概念" class="sidebar-link">Fiber 核心原理的几个关键概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_1-fiber-node" class="sidebar-link">1. Fiber Node</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_2-双缓冲技术" class="sidebar-link">2. 双缓冲技术</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_3-工作单元" class="sidebar-link">3. 工作单元</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_4-中断和恢复" class="sidebar-link">4. 中断和恢复</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_5-优先级和并发" class="sidebar-link">5. 优先级和并发</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_6-错误边界" class="sidebar-link">6. 错误边界</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#总结-3" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-scheduler核心原理react15-16-17-18变化都有哪些-batching在这个阶段里么-解决了什么原理是什么" class="sidebar-link">React Scheduler核心原理React15/16/17/18变化都有哪些？Batching在这个阶段里么，解决了什么原理是什么？</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-scheduler" class="sidebar-link">React Scheduler</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#batching" class="sidebar-link">Batching</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#automatic-batching-react-18-新特性" class="sidebar-link">Automatic Batching（React 18 新特性）</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#背景" class="sidebar-link">背景</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#传统的-batching" class="sidebar-link">传统的 Batching</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#特点" class="sidebar-link">特点</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#示例代码" class="sidebar-link">示例代码</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#hooks为什么不能写在条件判断、函数体里。我现在有业务场景就需要在里写怎么办呢" class="sidebar-link">Hooks为什么不能写在条件判断、函数体里。我现在有业务场景就需要在里写怎么办呢？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#hooks-为什么不能写在条件判断中" class="sidebar-link">Hooks 为什么不能写在条件判断中？</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#如果需要条件判断怎么办" class="sidebar-link">如果需要条件判断怎么办？</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#state直接在函数组件调用会造成无限渲染-原因是什么-怎么监控react无意义渲染-监控的原理是什么" class="sidebar-link">state直接在函数组件调用会造成无限渲染，原因是什么，怎么监控React无意义渲染，监控的原理是什么？</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#welldone-software-why-did-you-render" class="sidebar-link">@welldone-software/why-did-you-render</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#简介-3" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#工作原理" class="sidebar-link">工作原理</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#功能说明" class="sidebar-link">功能说明</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#dom-diff细节请详细描述一下-vue使用了双指针-react为什么没采用呢" class="sidebar-link">Dom Diff细节请详细描述一下？Vue使用了双指针，React为什么没采用呢？</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#fiber-的引入" class="sidebar-link">Fiber 的引入</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#fiber-的优点" class="sidebar-link">Fiber 的优点</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#fiber-架构的核心实现" class="sidebar-link">Fiber 架构的核心实现</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_1-设计目标不同" class="sidebar-link">1. 设计目标不同</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_2-灵活性要求" class="sidebar-link">2. 灵活性要求</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_3-可扩展性" class="sidebar-link">3. 可扩展性</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react如何实现自身的事件系统-什么叫合成事件" class="sidebar-link">React如何实现自身的事件系统？什么叫合成事件？</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#简介-4" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-合成事件的特点" class="sidebar-link">React 合成事件的特点</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#与原生-dom-事件的对比" class="sidebar-link">与原生 DOM 事件的对比</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#特殊情况" class="sidebar-link">特殊情况</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-17-的改进" class="sidebar-link">React 17 的改进</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-concurrent-mode是什么-react18是怎么实现的-他和usetransition有联系么" class="sidebar-link">React Concurrent Mode是什么？React18是怎么实现的？他和useTransition有联系么？</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#答案" class="sidebar-link">答案</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-concurrent-mode-的定义" class="sidebar-link">React Concurrent Mode 的定义</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#传统同步渲染-vs-concurrent-mode" class="sidebar-link">传统同步渲染 vs Concurrent Mode</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#usetransition-的作用" class="sidebar-link">useTransition 的作用</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#usetransition-在-concurrent-mode-中的使用" class="sidebar-link">useTransition 在 Concurrent Mode 中的使用</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#总结-4" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#将-vue-替换为-react-react-能提高-fps-吗-请给出理由" class="sidebar-link">将 Vue 替换为 React，React 能提高 FPS 吗？请给出理由</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#答案-2" class="sidebar-link">答案</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#_3-框架的大小" class="sidebar-link">3. 框架的大小</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#总结-5" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#lane-是什么-解决了-react-什么问题-原理是什么" class="sidebar-link">Lane 是什么？解决了 React 什么问题，原理是什么？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#答案-3" class="sidebar-link">答案</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#总结-6" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-fiernode链表伪代码" class="sidebar-link">React  FierNode链表伪代码</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-scheduler-涉及到核心微任务-宏任务代码输出" class="sidebar-link">React Scheduler 涉及到核心微任务，宏任务代码输出</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-dom-diff-原理" class="sidebar-link">React Dom Diff 原理？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#答案-4" class="sidebar-link">答案</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#算法核心步骤" class="sidebar-link">算法核心步骤</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-的同构开发你是如何部署的-使用-next-js-还是自己开发好-流式渲染是什么有什么好处" class="sidebar-link">React 的同构开发你是如何部署的？使用 Next.js 还是自己开发好？流式渲染是什么有什么好处？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#答案-5" class="sidebar-link">答案</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#关于部署方式" class="sidebar-link">关于部署方式</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#云平台的选择" class="sidebar-link">云平台的选择</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#关于流式渲染" class="sidebar-link">关于流式渲染</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#总结-7" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-服务端渲染需要进行-hydrate-吗-哪些版本不需要-我听说-qwik-是懒加载的-为什么呢" class="sidebar-link">React 服务端渲染需要进行 Hydrate 吗？哪些版本不需要？我听说 Qwik 是懒加载的，为什么呢？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#答案-6" class="sidebar-link">答案</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#react-同构渲染如何提高性能问题-都有哪些关键指标-同构解决了哪些性能指标" class="sidebar-link">React 同构渲染如何提高性能问题？都有哪些关键指标？同构解决了哪些性能指标？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#答案-7" class="sidebar-link">答案</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#关键性能指标" class="sidebar-link">关键性能指标</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#如何优化" class="sidebar-link">如何优化</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#总结-9" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#各个平台进行-javascript-冷启动的区别是什么" class="sidebar-link">各个平台进行 JavaScript 冷启动的区别是什么？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#答案-8" class="sidebar-link">答案</a></li></ul></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#同构注水与脱水是什么意思-react-进行-serverless-部署时项目实现效果是否变化" class="sidebar-link">同构注水与脱水是什么意思？React 进行 Serverless 部署时项目实现效果是否变化？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#答案-9" class="sidebar-link">答案</a></li><li class="sidebar-sub-header"><a href="/font-end-nodes/interview/types/27-面试小册子.html#说明" class="sidebar-link">说明</a></li></ul></li></ul></li><li><a href="/font-end-nodes/interview/types/28-面试小册子.html" class="sidebar-link">前端面试小册子</a></li><li><a href="/font-end-nodes/interview/types/29.面试小册子.html" class="sidebar-link">前端面试小册子-7</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>每日算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/font-end-nodes/interview/algorithm/" class="sidebar-link">算法题</a></li><li><a href="/font-end-nodes/interview/algorithm/01.算法基础.html" class="sidebar-link">算法基础</a></li><li><a href="/font-end-nodes/interview/algorithm/02.利用栈进行二叉树前序遍历.html" class="sidebar-link">利用栈进行二叉树前序遍历</a></li><li><a href="/font-end-nodes/interview/algorithm/03.有效括号.html" class="sidebar-link">有效括号</a></li><li><a href="/font-end-nodes/interview/algorithm/04.最近的请求次数.html" class="sidebar-link">最近的请求次数</a></li><li><a href="/font-end-nodes/interview/algorithm/05.链表.html" class="sidebar-link">链表</a></li><li><a href="/font-end-nodes/interview/algorithm/06.两数相加.html" class="sidebar-link">两数相加</a></li><li><a href="/font-end-nodes/interview/algorithm/07.删除链表中重复的元素.html" class="sidebar-link">删除链表中重复的元素</a></li><li><a href="/font-end-nodes/interview/algorithm/08.环形列表.html" class="sidebar-link">环形列表</a></li><li><a href="/font-end-nodes/interview/algorithm/09.两个数组交集.html" class="sidebar-link">两个数组交集</a></li><li><a href="/font-end-nodes/interview/algorithm/10.两数之和.html" class="sidebar-link">两数之和</a></li><li><a href="/font-end-nodes/interview/algorithm/11.无重复字符的最长子串.html" class="sidebar-link">无重复字符的最长子串</a></li><li><a href="/font-end-nodes/interview/algorithm/12.最小覆盖子串.html" class="sidebar-link">最小覆盖子串</a></li><li><a href="/font-end-nodes/interview/algorithm/13.实现树的深度优化.html" class="sidebar-link">实现树的深度优化</a></li><li><a href="/font-end-nodes/interview/algorithm/14.实现树的先中后.html" class="sidebar-link">实现树的遍历</a></li><li><a href="/font-end-nodes/interview/algorithm/15.二叉树最大深度.html" class="sidebar-link">二叉树最大深度</a></li><li><a href="/font-end-nodes/interview/algorithm/16.二叉树最小深度.html" class="sidebar-link">二叉树最小深度</a></li><li><a href="/font-end-nodes/interview/algorithm/17.二叉树的层序遍历.html" class="sidebar-link">二叉树的层序遍历</a></li><li><a href="/font-end-nodes/interview/algorithm/18. 二叉树的中序遍历.html" class="sidebar-link">二叉树的中序遍历</a></li><li><a href="/font-end-nodes/interview/algorithm/19.路径总和.html" class="sidebar-link">路径总和</a></li><li><a href="/font-end-nodes/interview/algorithm/20.克隆图.html" class="sidebar-link">克隆图</a></li><li><a href="/font-end-nodes/interview/algorithm/21.数组中的第K个最大元素.html" class="sidebar-link">数组中的第K个最大元素</a></li><li><a href="/font-end-nodes/interview/algorithm/22.前k个高频元素.html" class="sidebar-link">前 K 个高频元素</a></li><li><a href="/font-end-nodes/interview/algorithm/23.合并K个升序链表.html" class="sidebar-link">合并 K 个升序链表</a></li><li><a href="/font-end-nodes/interview/algorithm/24.图.html" class="sidebar-link">[图]</a></li><li><a href="/font-end-nodes/interview/algorithm/25.冒泡排序.html" class="sidebar-link">冒泡排序</a></li><li><a href="/font-end-nodes/interview/algorithm/26.选择排序.html" class="sidebar-link">[选择排序]</a></li><li><a href="/font-end-nodes/interview/algorithm/27.插入排序.html" class="sidebar-link">[插入排序]</a></li><li><a href="/font-end-nodes/interview/algorithm/28.归并排序.html" class="sidebar-link">[归并排序]</a></li><li><a href="/font-end-nodes/interview/algorithm/29.快速排序.html" class="sidebar-link">[快速排序]</a></li><li><a href="/font-end-nodes/interview/algorithm/30.顺序搜索.html" class="sidebar-link">[搜索排序]</a></li><li><a href="/font-end-nodes/interview/algorithm/31.使用JavaScript实现二分搜索.html" class="sidebar-link">[二分查找]</a></li><li><a href="/font-end-nodes/interview/algorithm/32.合并两个有序链表.html" class="sidebar-link">合并两个有序链表</a></li><li><a href="/font-end-nodes/interview/algorithm/33.猜数字大小.html" class="sidebar-link">猜数字大小</a></li><li><a href="/font-end-nodes/interview/algorithm/34.翻转二叉树.html" class="sidebar-link">翻转二叉树</a></li><li><a href="/font-end-nodes/interview/algorithm/35.相同的树.html" class="sidebar-link">相同的树</a></li><li><a href="/font-end-nodes/interview/algorithm/36. 对称二叉树.html" class="sidebar-link">对称二叉树</a></li><li><a href="/font-end-nodes/interview/algorithm/37.爬楼梯.html" class="sidebar-link">爬楼梯</a></li><li><a href="/font-end-nodes/interview/algorithm/38.打家劫舍.html" class="sidebar-link">打家劫舍</a></li><li><a href="/font-end-nodes/interview/algorithm/39.分发饼干.html" class="sidebar-link">发饼干</a></li><li><a href="/font-end-nodes/interview/algorithm/40.Implement MyReturnType.html" class="sidebar-link">Implement MyReturnType</a></li><li><a href="/font-end-nodes/interview/algorithm/41.两个算法.html" class="sidebar-link">两个算法</a></li><li><a href="/font-end-nodes/interview/algorithm/42.两个算法.html" class="sidebar-link">两个算法</a></li><li><a href="/font-end-nodes/interview/algorithm/43.两个算法.html" class="sidebar-link">两个算法</a></li><li><a href="/font-end-nodes/interview/algorithm/44.动态可展开.html" class="sidebar-link">动态可展开</a></li><li><a href="/font-end-nodes/interview/algorithm/45.ImplementAGenericDeepRead.html" class="sidebar-link">Implement A Generic DeepRead</a></li><li><a href="/font-end-nodes/interview/algorithm/46.ImplementAGenericTupleToU.html" class="sidebar-link">Implement a generic TupleToU</a></li><li><a href="/font-end-nodes/interview/algorithm/47.GivenAnArrayTransform.html" class="sidebar-link">/interview/algorithm/47.GivenAnArrayTransform.html</a></li><li><a href="/font-end-nodes/interview/algorithm/48.YouNeedToTypeAnObject.html" class="sidebar-link">You Need To Type An Object</a></li><li><a href="/font-end-nodes/interview/algorithm/49.CurryingIsTheTechniqueO.html" class="sidebar-link">Currying is the technique O</a></li><li><a href="/font-end-nodes/interview/algorithm/50.Implement.html" class="sidebar-link">Implement First</a></li><li><a href="/font-end-nodes/interview/algorithm/51.练练元祖length + infer深入玩法.html" class="sidebar-link">练练元祖length + infer深入玩法</a></li><li><a href="/font-end-nodes/interview/algorithm/52.ImplementBuilt-inExclude.html" class="sidebar-link">Implement built-in Exclude</a></li><li><a href="/font-end-nodes/interview/algorithm/53.ImplementGetRequired.html" class="sidebar-link">Implement GetRequired</a></li><li><a href="/font-end-nodes/interview/algorithm/54.TypeThefunctionPromiseAll.html" class="sidebar-link">Type thefunction PromiseAll</a></li><li><a href="/font-end-nodes/interview/algorithm/55.大模型.html" class="sidebar-link">大模型</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="前端面试小册子"><a href="#前端面试小册子" class="header-anchor">#</a> 前端面试小册子</h1> <h2 id="react15-161718都有愿些新变化"><a href="#react15-161718都有愿些新变化" class="header-anchor">#</a> React15/161718都有愿些新变化？</h2> <h3 id="react-版本对比"><a href="#react-版本对比" class="header-anchor">#</a> React 版本对比</h3> <table><thead><tr><th>React 版本</th> <th>核心架构变化</th> <th>新增/改进特性</th> <th>对开发者影响</th> <th>事件处理机制</th></tr></thead> <tbody><tr><td>React 15</td> <td>传统 Stack 协调算法</td> <td>功能较稳定，无重大变革</td> <td>构建 UI 需要更冗余，不够灵活</td> <td>事件委托在 document 上</td></tr> <tr><td>React 16</td> <td>Fiber 架构引入</td> <td>异步可中断渲染架构打底，新增 Error Boundaries（隔离错误）、Portals（跨 DOM 挂载）、可返回数组/字符串/Fragments</td> <td>编写组件更灵活，错误处理更优雅，SSR 性能提升</td> <td>事件仍委托在 document，机制未大改</td></tr> <tr><td>React 17</td> <td>过渡性版本，无显著新功能</td> <td>无重大新增功能，以活跃和稳定为主</td> <td>减少升级阻力，更易多版本共存</td> <td>事件委托从 document 转移至 React 容器根节点，为多根实例及未来特性做准备</td></tr> <tr><td>React 18</td> <td>并发特性（Concurrent Rendering），Suspense 完善、自动批处理，Transitions（useTransition）</td> <td>新增 createRoot API（并发渲染）、Suspense 在数据加载中更实用、自动批处理状态更新、useTransition 标记非紧急更新</td> <td>更流畅的用户体验、更高效的数据加载和渲染流程，严格模式下更易发现逻辑问题</td> <td>与 17 类似的事件机制，支持多根和并发场景</td></tr> <tr><td>React 19</td> <td>增强并发模式，优化性能</td> <td>支持 Streaming SSR 的改进、全新的 <code>useCache</code> API 用于数据缓存管理、改进的 Suspense 支持更多场景</td> <td>提高大规模应用的性能和开发效率，进一步简化数据加载和缓存逻辑</td> <td>事件机制与 18 类似，继续优化并发事件处理</td></tr></tbody></table> <h3 id="top-level-await"><a href="#top-level-await" class="header-anchor">#</a> top-level await</h3> <ul><li>top-level await 是 JavaScript 中的一个特性，允许在模块的顶层直接使用 await，而无需将其包裹在异步函数中。</li> <li>在 React 中，引入了 top-level await 的支持后，可以让开发者在组件的定义阶段处理异步逻辑（如数据预取或动态导入），而无需额外的封装。</li></ul> <h3 id="react-中的-use-使用指南"><a href="#react-中的-use-使用指南" class="header-anchor">#</a> React 中的 <code>use</code> 使用指南</h3> <h4 id="什么是-use"><a href="#什么是-use" class="header-anchor">#</a> 什么是 <code>use</code></h4> <ul><li><code>use</code> 是 React 引入的新特性，用于简化异步数据加载逻辑。</li> <li>它允许直接在组件中等待（<code>await</code>）异步操作。</li> <li>需要配合 <code>Suspense</code> 使用，否则会报错。</li></ul> <hr> <h4 id="基础用法"><a href="#基础用法" class="header-anchor">#</a> <strong>基础用法</strong></h4> <p><code>use</code> 会挂起（suspend）组件的渲染，直到异步函数完成。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="react-19-中的-formstate-和-formaction"><a href="#react-19-中的-formstate-和-formaction" class="header-anchor">#</a> React 19 中的 <code>formState</code> 和 <code>formAction</code></h2> <h3 id="它们是否是-react-19-的新特性"><a href="#它们是否是-react-19-的新特性" class="header-anchor">#</a> <strong>它们是否是 React 19 的新特性？</strong></h3> <p><code>formState</code> 和 <code>formAction</code> 并不是 React 19 新增的核心特性，而是现代 Web 开发（包括 React 生态）中的常见概念。在 React 19 的框架支持下，这些功能可以更加高效地集成和使用。</p> <ul><li><strong><code>formState</code></strong>：常见于表单状态管理库，如 <code>react-hook-form</code> 或 <code>Formik</code>，用于跟踪表单的状态和验证。</li> <li><strong><code>formAction</code></strong>：是 HTML 的标准属性，用于定义表单提交的目标路径，但在现代框架中（如 React 和 Next.js），可以动态使用。</li></ul> <hr> <h3 id="formstate-的作用"><a href="#formstate-的作用" class="header-anchor">#</a> <strong><code>formState</code> 的作用</strong></h3> <h4 id="定义"><a href="#定义" class="header-anchor">#</a> <strong>定义</strong></h4> <ul><li><code>formState</code> 是表单的状态管理工具，用于实时跟踪表单的输入值、验证状态、提交状态等。</li> <li>虽然 React 本身没有内置 <code>formState</code>，但通过库（如 <code>react-hook-form</code>）可以轻松实现。</li></ul> <h4 id="常见属性"><a href="#常见属性" class="header-anchor">#</a> <strong>常见属性</strong></h4> <ul><li><strong><code>errors</code></strong>：字段的验证错误信息。</li> <li><strong><code>isSubmitting</code></strong>：表单是否正在提交。</li> <li><strong><code>isValid</code></strong>：表单验证是否通过。</li> <li><strong><code>dirtyFields</code></strong>：用户已修改的字段。</li></ul> <h4 id="示例"><a href="#示例" class="header-anchor">#</a> <strong>示例</strong></h4> <p>以下是使用 <code>react-hook-form</code> 的例子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useForm <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-hook-form'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> register<span class="token punctuation">,</span> handleSubmit<span class="token punctuation">,</span> formState <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">onSubmit</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token function">handleSubmit</span><span class="token punctuation">(</span>onSubmit<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input <span class="token punctuation">{</span><span class="token operator">...</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">required</span><span class="token operator">:</span> <span class="token string">'Username is required'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>formState<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>username <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span>formState<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>username<span class="token punctuation">.</span>message<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token punctuation">)</span><span class="token punctuation">}</span>

      <span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">&quot;submit&quot;</span> disabled<span class="token operator">=</span><span class="token punctuation">{</span>formState<span class="token punctuation">.</span>isSubmitting<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        Submit
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="usetransition是提解决了什么-解决了什么"><a href="#usetransition是提解决了什么-解决了什么" class="header-anchor">#</a> useTransition是提解决了什么？ 解决了什么？</h2> <p>useTransition 的出现是为了解决在复杂更新场景下的界面卡顿问题，让用户在高优先级操作（如输入）期间仍能得到流畅即时的反馈，而较为昂贵的状态更新（如数据加载、列表过滤）则在后台以较低优先级完成。</p> <h1 id="react-hook-usetransition"><a href="#react-hook-usetransition" class="header-anchor">#</a> React Hook: <code>useTransition</code></h1> <h2 id="简介"><a href="#简介" class="header-anchor">#</a> <strong>简介</strong></h2> <p><code>useTransition</code> 是 React 18 中引入的一个 Hook，主要用于管理非紧急更新的优先级。它允许开发者将某些状态更新标记为非紧急任务，从而避免阻塞用户交互操作（如输入框或按钮的即时响应）。</p> <hr> <h2 id="作用"><a href="#作用" class="header-anchor">#</a> <strong>作用</strong></h2> <ol><li><strong>分离高优先级和低优先级的状态更新</strong>：用户输入（高优先级）与相关的列表过滤（低优先级）可以独立处理。</li> <li><strong>避免界面卡顿</strong>：当数据处理较多时，通过标记非紧急任务，保持界面的高响应性。</li></ol> <hr> <h2 id="语法"><a href="#语法" class="header-anchor">#</a> <strong>语法</strong></h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><strong><code>isPending</code></strong>：一个布尔值，表示低优先级的任务是否仍在进行中。</li> <li><strong><code>startTransition</code></strong>：一个函数，用于包装非紧急更新。</li></ul> <hr> <h2 id="用法示例"><a href="#用法示例" class="header-anchor">#</a> <strong>用法示例</strong></h2> <h3 id="_1-基本示例-处理输入和过滤列表"><a href="#_1-基本示例-处理输入和过滤列表" class="header-anchor">#</a> <strong>1. 基本示例：处理输入和过滤列表</strong></h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useTransition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>query<span class="token punctuation">,</span> setQuery<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>results<span class="token punctuation">,</span> setResults<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> value <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token function">setQuery</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 将过滤逻辑标记为非紧急任务</span>
    <span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> filteredResults <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Item </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">setResults</span><span class="token punctuation">(</span>filteredResults<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input
        type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span>
        value<span class="token operator">=</span><span class="token punctuation">{</span>query<span class="token punctuation">}</span>
        onChange<span class="token operator">=</span><span class="token punctuation">{</span>handleChange<span class="token punctuation">}</span>
        placeholder<span class="token operator">=</span><span class="token string">&quot;Search items&quot;</span>
      <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>isPending <span class="token operator">&amp;&amp;</span> <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>Loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>results<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
          <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>result<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span>
</code></pre></div><hr> <h3 id="_2-优化繁重任务的用户体验"><a href="#_2-优化繁重任务的用户体验" class="header-anchor">#</a> <strong>2. 优化繁重任务的用户体验</strong></h3> <p>当存在耗时的状态更新（如大型表格渲染或复杂数据计算）时，可以通过 <code>useTransition</code> 标记更新为非紧急。</p> <h4 id="示例-数据模拟延迟加载"><a href="#示例-数据模拟延迟加载" class="header-anchor">#</a> 示例：数据模拟延迟加载</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useTransition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">ExpensiveComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>data<span class="token punctuation">,</span> setData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prev</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> prev <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 模拟一个耗时任务</span>
      <span class="token keyword">const</span> generatedData <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Item </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i <span class="token operator">+</span> count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">setData</span><span class="token punctuation">(</span>generatedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Generate Data<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>isPending <span class="token operator">?</span> <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>Loading data<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span> <span class="token operator">:</span> <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>Data loaded<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>data<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
          <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> ExpensiveComponent<span class="token punctuation">;</span>
</code></pre></div><hr> <h3 id="_3-动态渲染分页列表"><a href="#_3-动态渲染分页列表" class="header-anchor">#</a> <strong>3. 动态渲染分页列表</strong></h3> <h4 id="示例-分页切换"><a href="#示例-分页切换" class="header-anchor">#</a> 示例：分页切换</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useTransition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">PaginatedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>page<span class="token punctuation">,</span> setPage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>items<span class="token punctuation">,</span> setItems<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handlePageChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">newPage</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setPage</span><span class="token punctuation">(</span>newPage<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 模拟数据加载</span>
      <span class="token keyword">const</span> newItems <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Item </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token punctuation">(</span>newPage <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">setItems</span><span class="token punctuation">(</span>newItems<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">handlePageChange</span><span class="token punctuation">(</span>page <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span> disabled<span class="token operator">=</span><span class="token punctuation">{</span>page <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
          Previous
        <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">handlePageChange</span><span class="token punctuation">(</span>page <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Next<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>isPending <span class="token operator">&amp;&amp;</span> <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>Loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>items<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
          <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> PaginatedList<span class="token punctuation">;</span>
</code></pre></div><hr> <h2 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> <strong>注意事项</strong></h2> <ol><li><strong>非紧急更新的限制</strong>：<code>useTransition</code> 仅适用于标记非紧急任务，不能用于高优先级任务。</li> <li><strong>性能优化</strong>：它不会减少计算时间，只是将其推迟到更适合的时间运行。</li> <li><strong>并发模式</strong>：<code>useTransition</code> 需要 React 的并发渲染支持，在 React 18 中默认启用。</li></ol> <hr> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> <strong>总结</strong></h2> <ul><li><code>useTransition</code> 是 React 18 的强大工具，用于优化用户体验。</li> <li>它帮助开发者区分高优先级任务（如用户输入）和低优先级任务（如复杂计算或数据更新）。</li> <li>配合 React 的 Concurrent Rendering，可以显著提升界面交互的流畅性。</li></ul> <p>适用于需要处理大规模数据或高频交互的应用场景，例如搜索、分页、或动态表格更新。</p> <h1 id="react-hooks-usetransition-和-usedeferredvalue-的区别"><a href="#react-hooks-usetransition-和-usedeferredvalue-的区别" class="header-anchor">#</a> React Hooks: <code>useTransition</code> 和 <code>useDeferredValue</code> 的区别</h1> <h2 id="简介-2"><a href="#简介-2" class="header-anchor">#</a> <strong>简介</strong></h2> <p><code>useTransition</code> 和 <code>useDeferredValue</code> 都是 React 18 中引入的用于优化用户体验的 Hook，但它们的用途和功能有所不同。</p> <hr> <h2 id="_1-usetransition"><a href="#_1-usetransition" class="header-anchor">#</a> <strong>1. <code>useTransition</code></strong></h2> <h3 id="核心概念"><a href="#核心概念" class="header-anchor">#</a> <strong>核心概念</strong></h3> <ul><li>用于管理<strong>非紧急更新</strong>，通过延迟低优先级任务的执行，优先处理高优先级任务（如用户输入）。</li> <li>适合在需要分离高优先级和低优先级任务的场景中使用。</li></ul> <h3 id="语法-2"><a href="#语法-2" class="header-anchor">#</a> <strong>语法</strong></h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><strong><code>isPending</code></strong>: 一个布尔值，表示低优先级任务是否正在进行。</li> <li><strong><code>startTransition</code></strong>: 一个函数，用于包装非紧急任务。</li></ul> <h3 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> <strong>使用场景</strong></h3> <ul><li>高优先级任务（如用户输入）与低优先级任务（如复杂计算或数据更新）的分离。</li> <li>确保用户交互的即时响应性，同时后台处理复杂的低优先级任务。</li></ul> <h3 id="示例-2"><a href="#示例-2" class="header-anchor">#</a> <strong>示例</strong></h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useTransition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SearchComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>query<span class="token punctuation">,</span> setQuery<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>results<span class="token punctuation">,</span> setResults<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> value <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token function">setQuery</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> filteredResults <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Item </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">setResults</span><span class="token punctuation">(</span>filteredResults<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> value<span class="token operator">=</span><span class="token punctuation">{</span>query<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span>handleChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>isPending <span class="token operator">&amp;&amp;</span> <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>Loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>results<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
          <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>result<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <h2 id="_2-usedeferredvalue"><a href="#_2-usedeferredvalue" class="header-anchor">#</a> <strong>2. <code>useDeferredValue</code></strong></h2> <h3 id="核心概念-2"><a href="#核心概念-2" class="header-anchor">#</a> <strong>核心概念</strong></h3> <ul><li>用于将某个状态的值标记为<strong>延迟更新</strong>，适合那些因计算复杂或渲染昂贵而导致性能问题的场景。</li> <li>不直接控制状态的更新，而是返回一个延迟的值。</li></ul> <h3 id="语法-3"><a href="#语法-3" class="header-anchor">#</a> <strong>语法</strong></h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> deferredValue <span class="token operator">=</span> <span class="token function">useDeferredValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><strong><code>deferredValue</code></strong>: 返回延迟更新的值，与原始值可能不同步，React 会在有空闲时间时更新它。</li></ul> <h3 id="使用场景-2"><a href="#使用场景-2" class="header-anchor">#</a> <strong>使用场景</strong></h3> <ul><li>优化耗时任务的渲染（如大规模列表或复杂计算），使得当前页面的渲染更流畅。</li> <li>延迟不重要的状态变化，确保用户界面及时响应。</li></ul> <h3 id="示例-3"><a href="#示例-3" class="header-anchor">#</a> <strong>示例</strong></h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useDeferredValue <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">DeferredSearch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>query<span class="token punctuation">,</span> setQuery<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> deferredQuery <span class="token operator">=</span> <span class="token function">useDeferredValue</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> results <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Item </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>deferredQuery<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input
        type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span>
        value<span class="token operator">=</span><span class="token punctuation">{</span>query<span class="token punctuation">}</span>
        onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setQuery</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span>
        placeholder<span class="token operator">=</span><span class="token string">&quot;Search items&quot;</span>
      <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>results<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
          <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>result<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <h2 id="对比总结"><a href="#对比总结" class="header-anchor">#</a> <strong>对比总结</strong></h2> <table><thead><tr><th>特性</th> <th><code>useTransition</code></th> <th><code>useDeferredValue</code></th></tr></thead> <tbody><tr><td><strong>用途</strong></td> <td>控制非紧急任务的执行（如低优先级状态更新）。</td> <td>延迟传递的值，避免复杂状态变化阻塞界面渲染。</td></tr> <tr><td><strong>优先级控制</strong></td> <td>高优先级任务立即执行，低优先级任务延迟执行。</td> <td>自动延迟值的同步更新，渲染更流畅。</td></tr> <tr><td><strong>触发方式</strong></td> <td>使用 <code>startTransition</code> 包裹非紧急任务。</td> <td>直接延迟传递状态值，React 内部控制。</td></tr> <tr><td><strong>适用场景</strong></td> <td>高频用户交互（如输入框）与复杂任务（如过滤列表）分离。</td> <td>优化昂贵的状态计算（如大列表渲染、复杂筛选逻辑）。</td></tr> <tr><td><strong>返回值</strong></td> <td>布尔值 <code>isPending</code> 和任务触发器 <code>startTransition</code>。</td> <td>延迟更新的值 <code>deferredValue</code>。</td></tr> <tr><td><strong>依赖 React 并发模式</strong></td> <td>是</td> <td>是</td></tr></tbody></table> <hr> <h2 id="使用建议"><a href="#使用建议" class="header-anchor">#</a> <strong>使用建议</strong></h2> <ul><li><p><strong>使用 <code>useTransition</code>：</strong></p> <ul><li>需要手动控制优先级更新时（如用户输入和后台数据处理分离）。</li> <li>对复杂状态的更新进行分类，高优先级任务应及时响应。</li></ul></li> <li><p><strong>使用 <code>useDeferredValue</code>：</strong></p> <ul><li>当只需要延迟某个状态的传递，而不需要明确的优先级控制时。</li> <li>优化复杂状态的传递逻辑，保持用户界面的响应性。</li></ul></li></ul> <hr> <h2 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> <strong>总结</strong></h2> <p><code>useTransition</code> 和 <code>useDeferredValue</code> 都是 React 提供的性能优化工具，它们适用于不同的场景：</p> <ul><li><strong><code>useTransition</code></strong>：用于手动管理任务优先级，适合处理复杂的异步更新场景。</li> <li><strong><code>useDeferredValue</code></strong>：用于延迟状态值的传递，适合单一状态优化的场景。</li></ul> <p>根据项目需求选择合适的工具，以提升用户体验和界面性能。</p> <h2 id="react整体渲染流程请描述下-。那你能说下双缓存是在哪个阶段设置的么-优缺点是什么"><a href="#react整体渲染流程请描述下-。那你能说下双缓存是在哪个阶段设置的么-优缺点是什么" class="header-anchor">#</a> React整体渲染流程请描述下？ 。那你能说下双缓存是在哪个阶段设置的么？优缺点是什么？</h2> <table><thead><tr><th>阶段</th> <th>描述</th></tr></thead> <tbody><tr><td><strong>初始化阶段 (Initialization)</strong></td> <td>创建 Fiber 节点，代表整个 React 应用的根组件；调用根组件的 <code>render</code> 方法，创建初始的虚拟 DOM 树。</td></tr> <tr><td><strong>调度阶段 (Scheduler)</strong></td> <td>使用调度器（Scheduler）调度更新任务，决定何时执行更新任务。</td></tr> <tr><td></td> <td>- 检查是否有更高优先级的任务（如用户交互）。</td></tr> <tr><td></td> <td>- 将高优先级任务分配到不同的任务队列中（lane）。</td></tr> <tr><td><strong>协调阶段 (Reconciliation)</strong></td> <td>从任务队列中取出任务，比较前后两个虚拟 DOM 树的差异，找到需要更新的部分；使用 DOM Diff 算法计算差异，并生成相应的更新指令。</td></tr> <tr><td><strong>生命周期阶段 (Lifecycle)</strong></td> <td>根据组件的生命周期方法（如 <code>componentDidMount</code>、<code>componentDidUpdate</code>）调用对应的钩子函数，处理组件生命周期事件。</td></tr> <tr><td><strong>渲染阶段 (Render)</strong></td> <td>React 根据组件状态变化或 props 变化，触发组件更新：</td></tr> <tr><td></td> <td>- 函数组件：重新执行函数体。</td></tr> <tr><td></td> <td>- 类组件：调用 <code>render</code> 方法。</td></tr> <tr><td></td> <td>如果组件中使用了 Hooks，则按 Hooks 的调用顺序依次执行（如 <code>useState</code>、<code>useEffect</code>、<code>useContext</code>）。</td></tr> <tr><td><strong>Hooks 执行</strong></td> <td>在渲染阶段，React 会按照 Hooks 的顺序执行。</td></tr> <tr><td></td> <td>- 执行 <code>useState</code>、<code>useEffect</code>、<code>useContext</code> 等 Hooks。</td></tr> <tr><td></td> <td>- React 18 支持自动化批处理（如多个 <code>setState</code> 合并到一次更新）。</td></tr> <tr><td><strong>提交阶段 (Commit)</strong></td> <td>将渲染阶段生成的更新应用到真实 DOM 中，完成页面更新；执行可能存在的生命周期方法（如 <code>componentDidMount</code>、<code>componentDidUpdate</code>）或其他副作用。</td></tr> <tr><td><strong>重复步骤 2-7</strong></td> <td>根据交互和状态变化，React 会不断重复调度、协调、渲染和提交的过程，循环执行以实现页面的持续更新。</td></tr></tbody></table> <h2 id="fiber架构原理你能细致描达下么"><a href="#fiber架构原理你能细致描达下么" class="header-anchor">#</a> Fiber架构原理你能细致描达下么？</h2> <h2 id="react-fiber-核心概念和原理"><a href="#react-fiber-核心概念和原理" class="header-anchor">#</a> React Fiber 核心概念和原理</h2> <h2 id="fiber-是什么"><a href="#fiber-是什么" class="header-anchor">#</a> Fiber 是什么？</h2> <ul><li>Fiber 是 React 16 中引入的一种新的调和（Reconciliation）引擎。在这个架构下，React 能够有效调度和分配优先级，使 React 可以在执行过程中暂停、中断和恢复工作，从而实现时间切片（Time Slicing）和并发模式（Concurrent Mode）等特性。</li></ul> <hr> <h2 id="fiber-核心原理的几个关键概念"><a href="#fiber-核心原理的几个关键概念" class="header-anchor">#</a> <strong>Fiber 核心原理的几个关键概念</strong></h2> <h3 id="_1-fiber-node"><a href="#_1-fiber-node" class="header-anchor">#</a> 1. <strong>Fiber Node</strong></h3> <ul><li>每个 React 组件都有一个对应的 Fiber 节点。</li> <li>Fiber 节点用于保存组件的状态、组件类型及其他信息。</li> <li>每个 Fiber 节点都指向一个父节点、子节点和兄弟节点，组成一个 Fiber 树。</li></ul> <h3 id="_2-双缓冲技术"><a href="#_2-双缓冲技术" class="header-anchor">#</a> 2. <strong>双缓冲技术</strong></h3> <ul><li>Fiber 架构采用了双缓冲技术，即两棵 Fiber 树：
<ul><li><strong>当前显示的 Fiber 树（Current Fiber Tree）</strong></li> <li><strong>即将更新的 Fiber 树（Work-in-Progress Fiber Tree）</strong></li></ul></li> <li>这种方式可以避免在直接操作 DOM 的同时出现错误，提高了性能，并能支持错误边界和回溯到稳定状态。</li></ul> <h3 id="_3-工作单元"><a href="#_3-工作单元" class="header-anchor">#</a> 3. <strong>工作单元</strong></h3> <ul><li>React 的渲染过程可以看作是一系列的工作单元。</li> <li>每次循环中，React 会选取一个 Fiber 节点，为每个节点调用对应的生命周期方法，生成对应的 DOM 更新。</li> <li>如果在渲染过程中被打断，React 可以从中断点恢复工作。</li></ul> <h3 id="_4-中断和恢复"><a href="#_4-中断和恢复" class="header-anchor">#</a> 4. <strong>中断和恢复</strong></h3> <ul><li>Fiber 通过优先级机制允许中断和恢复工作：
<ul><li>React 将工作拆分为小任务，每个任务的执行时间不超过一个间隔，从而实现时间切片（Time Slicing）。</li> <li>React 可以在任务执行中暂停，出让控制权，优先处理高优先级的工作，例如用户交互。</li></ul></li></ul> <h3 id="_5-优先级和并发"><a href="#_5-优先级和并发" class="header-anchor">#</a> 5. <strong>优先级和并发</strong></h3> <ul><li>不同的任务可以被赋予不同的优先级：
<ul><li>用户交互会被赋予最高优先级。</li> <li>后台数据更新等次要任务会被延后执行。</li></ul></li> <li>这种机制允许 React 在低优先级任务中暂停，及时响应高优先级任务。</li></ul> <h3 id="_6-错误边界"><a href="#_6-错误边界" class="header-anchor">#</a> 6. <strong>错误边界</strong></h3> <ul><li>如果在更新过程中发生错误，React 会通过错误边界捕获异常，避免整个组件树崩溃。</li> <li>错误边界可以将错误隔离到特定组件，同时提供备用 UI。</li></ul> <hr> <h2 id="总结-3"><a href="#总结-3" class="header-anchor">#</a> <strong>总结</strong></h2> <p>Fiber 是 React 的一项重要技术改进。它带来了许多新特性，如更细粒度的任务拆分、更高效的错误捕获机制以及时间切片的实现，使 React 在处理用户界面时更高效、更流畅。</p> <h2 id="react-scheduler核心原理react15-16-17-18变化都有哪些-batching在这个阶段里么-解决了什么原理是什么"><a href="#react-scheduler核心原理react15-16-17-18变化都有哪些-batching在这个阶段里么-解决了什么原理是什么" class="header-anchor">#</a> React Scheduler核心原理React15/16/17/18变化都有哪些？Batching在这个阶段里么，解决了什么原理是什么？</h2> <h1 id="react-scheduler-与-batching-特性说明"><a href="#react-scheduler-与-batching-特性说明" class="header-anchor">#</a> React Scheduler 与 Batching 特性说明</h1> <h2 id="react-scheduler"><a href="#react-scheduler" class="header-anchor">#</a> React Scheduler</h2> <p>React Scheduler 是一个 React 内部的任务调度器。它主要用于在执行长期任务的空闲时间内有机会处理其他的任务，比如用户输入和动画，以提高应用的响应速度。这也是 React 中时间切片（Time Slicing）的核心实现。</p> <ul><li><strong>React 16：</strong> Scheduler 作为一个实验性功能被引入，用于实现新的 Fiber 架构和时间切片。</li> <li><strong>React 17：</strong> Scheduler 并没有明显变化，主要在于更改事件系统，使得 React 与原生 JavaScript 的兼容性更好。</li> <li><strong>React 18：</strong> Scheduler 将提供更完善的利用，以支持并发模式（Concurrent Mode）和新的 Suspense 特性。</li></ul> <h2 id="batching"><a href="#batching" class="header-anchor">#</a> Batching</h2> <p><strong>Batching</strong> 是 React 的一个重要特性，它允许 React 将多个状态更新合并为一次渲染，从而减少不必要的渲染次数和 DOM 更新，提高性能。在 React 的历史版本中，Batching 主要在 React 的事件处理函数和生命周期方法中生效；在异步代码等环境中，Batching 不会发生，每个状态更新都会导致一次渲染。</p> <h3 id="automatic-batching-react-18-新特性"><a href="#automatic-batching-react-18-新特性" class="header-anchor">#</a> Automatic Batching（React 18 新特性）</h3> <p>在 React 18 中，引入了新的特性 <strong>automatic batching</strong>。当代码里出现多个状态更新时，它们会被自动合并为一次渲染，不再局限于事件处理或生命周期内。这大大简化了开发者的心智负担，不必手动考虑多次状态更新是否需要手动 batch。</p> <p>下面是一个示例：在异步函数（如 <code>setTimeout</code>）中执行两个状态更新，也会合并为一次渲染：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h1 id="react-18-的-automatic-batching"><a href="#react-18-的-automatic-batching" class="header-anchor">#</a> React 18 的 Automatic Batching</h1> <h2 id="背景"><a href="#背景" class="header-anchor">#</a> <strong>背景</strong></h2> <p><code>batching</code> 是 React 的一种优化机制，用于减少不必要的渲染和 DOM 更新，从而提高应用性能。<br>
传统的 batching 在 React 中已经存在，但其作用范围有限，React 18 引入了更强大的 <strong>Automatic Batching</strong>。</p> <hr> <h2 id="传统的-batching"><a href="#传统的-batching" class="header-anchor">#</a> <strong>传统的 Batching</strong></h2> <h3 id="特点"><a href="#特点" class="header-anchor">#</a> <strong>特点</strong></h3> <ul><li>在 React 的历史版本中，只有在 React 内部的生命周期方法中，多个状态更新才会自动合并为一次渲染。</li> <li>在异步代码中，例如 <code>setTimeout</code> 或 <code>Promise</code>，React 并不会对状态更新进行 batching，每次状态更新都会触发一次渲染。</li></ul> <h3 id="示例代码"><a href="#示例代码" class="header-anchor">#</a> <strong>示例代码</strong></h3> <h4 id="传统生命周期中的-batching"><a href="#传统生命周期中的-batching" class="header-anchor">#</a> 传统生命周期中的 batching</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>代码执行一次</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>会触发两次</p> <h4 id="react-18-的-automatic-batching-2"><a href="#react-18-的-automatic-batching-2" class="header-anchor">#</a> React 18 的 Automatic Batching</h4> <ul><li>引入了全新的 Automatic Batching 机制。</li> <li>只要是连续的状态更新，无论它们发生在同步还是异步代码中，都可以自动合并为一次渲染。</li> <li>提高了性能，开发者无需担心状态更新是否在一个 batch 中。</li></ul> <p>React 18 中的异步状态更新</p> <div class="language-javaScript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="hooks为什么不能写在条件判断、函数体里。我现在有业务场景就需要在里写怎么办呢"><a href="#hooks为什么不能写在条件判断、函数体里。我现在有业务场景就需要在里写怎么办呢" class="header-anchor">#</a> Hooks为什么不能写在条件判断、函数体里。我现在有业务场景就需要在里写怎么办呢？</h2> <h3 id="hooks-为什么不能写在条件判断中"><a href="#hooks-为什么不能写在条件判断中" class="header-anchor">#</a> Hooks 为什么不能写在条件判断中？</h3> <p>React 通过单向链表保存 Hooks 状态，必须按固定顺序依次调用每个 Hook，否则会导致状态和副作用错位。</p> <h3 id="如果需要条件判断怎么办"><a href="#如果需要条件判断怎么办" class="header-anchor">#</a> 如果需要条件判断怎么办？</h3> <ul><li>将逻辑提取到 Hooks 内部，或者使用外部状态管理工具（如 zustand）来实现条件分支。</li></ul> <div class="language-text extra-class"><pre class="language-text"><code>    react-use
    react-hookable
</code></pre></div><h3 id="state直接在函数组件调用会造成无限渲染-原因是什么-怎么监控react无意义渲染-监控的原理是什么"><a href="#state直接在函数组件调用会造成无限渲染-原因是什么-怎么监控react无意义渲染-监控的原理是什么" class="header-anchor">#</a> state直接在函数组件调用会造成无限渲染，原因是什么，怎么监控React无意义渲染，监控的原理是什么？</h3> <p>如果在函数组件的主函数体中调用 setState，状态更新会触发渲染，渲染又触发状态更新，形成无限循环。</p> <p>将状态更新逻辑放入 useEffect 等副作用中，避免在函数体直接调用 setState。</p> <p>使用 why-did-you-render 监控无意义渲染，检测 props 和 state 是否发生实际变化。</p> <p>基于 React.memo 的浅比较机制，判断前后 props 和 state 的变化。如果没有变化却发生渲染，会在控制台打印警告。</p> <h2 id="welldone-software-why-did-you-render"><a href="#welldone-software-why-did-you-render" class="header-anchor">#</a> @welldone-software/why-did-you-render</h2> <h3 id="简介-3"><a href="#简介-3" class="header-anchor">#</a> <strong>简介</strong></h3> <p><code>@welldone-software/why-did-you-render</code> 是一个用于调试 React 中不必要重渲染的问题的工具。<br>
它可以帮助开发者追踪并识别由 prop 或 state 的不必要变化而触发的重渲染，从而提高应用的性能。</p> <hr> <h3 id="工作原理"><a href="#工作原理" class="header-anchor">#</a> <strong>工作原理</strong></h3> <ul><li>当你在应用中使用该库时，它会通过包装组件，重写它们的 <code>shouldComponentUpdate</code>（类组件）或 <code>React.memo</code>（函数组件）方法。<br>
在这些方法中，它会比较前后两次渲染的 <code>props</code> 和 <code>state</code> 值。</li></ul> <hr> <h3 id="功能说明"><a href="#功能说明" class="header-anchor">#</a> <strong>功能说明</strong></h3> <ol><li>如果 <code>props</code> 或 <code>state</code> 的值在两次渲染之间没有发生真正的变化，但组件仍然被重新渲染了，<br>
`@welldone-software/why-did-you</li></ol> <h2 id="dom-diff细节请详细描述一下-vue使用了双指针-react为什么没采用呢"><a href="#dom-diff细节请详细描述一下-vue使用了双指针-react为什么没采用呢" class="header-anchor">#</a> Dom Diff细节请详细描述一下？Vue使用了双指针，React为什么没采用呢？</h2> <h1 id="vue-与-react-在-diff-算法上的对比"><a href="#vue-与-react-在-diff-算法上的对比" class="header-anchor">#</a> Vue 与 React 在 Diff 算法上的对比</h1> <table><thead><tr><th><strong>对比维度</strong></th> <th><strong>Vue 的双指针 Diff</strong></th> <th><strong>React 的 Key-based Diff</strong></th></tr></thead> <tbody><tr><td><strong>算法基础</strong></td> <td>双指针算法，从两端同时比较节点；Vue 3 最长递增子序列。</td> <td>基于 <code>key</code> 的唯一性标识，逐层比较组件树。</td></tr> <tr><td><strong>适用场景</strong></td> <td>更适合动态列表（如 <code>v-for</code> 渲染）。</td> <td>通用性更强，适合复杂组件树和跨层级更新。</td></tr> <tr><td><strong>实现方式</strong></td> <td>比较节点的实际位置，操作具体 DOM 节点。</td> <td>比较组件的 <code>key</code> 和类型，操作虚拟 DOM。</td></tr> <tr><td><strong>性能复杂度</strong></td> <td><code>O(n)</code>，高效处理列表操作。</td> <td><code>O(n)</code>，通过 <code>key</code> 跳过无关节点。</td></tr> <tr><td><strong>灵活性</strong></td> <td>模板驱动，更新逻辑明确。</td> <td>灵活性更高，适配更多动态场景。</td></tr> <tr><td><strong>设计理念</strong></td> <td>更关注视图更新和 DOM 操作。</td> <td>更关注组件复用和状态管理。</td></tr></tbody></table> <h1 id="react-fiber-架构介绍及双指针算法对比"><a href="#react-fiber-架构介绍及双指针算法对比" class="header-anchor">#</a> React Fiber 架构介绍及双指针算法对比</h1> <h2 id="fiber-的引入"><a href="#fiber-的引入" class="header-anchor">#</a> <strong>Fiber 的引入</strong></h2> <p>React 在其 16 版本中引入了 Fiber 架构，重新设计了调度和渲染机制。Fiber 架构并没有采用双指针算法，而是引入了一种基于链表的单链表遍历方式，重点在于任务的<strong>可中断和优先级调度</strong>。</p> <hr> <h2 id="fiber-的优点"><a href="#fiber-的优点" class="header-anchor">#</a> <strong>Fiber 的优点</strong></h2> <ol><li><p><strong>可中断的更新</strong>：</p> <ul><li>Fiber 架构将渲染任务拆分为可以中断的更小单元，允许更高优先级的任务（如用户交互）插入执行，提升用户体验的流畅度。</li></ul></li> <li><p><strong>优先级调度</strong>：</p> <ul><li>Fiber 支持不同优先级的任务，React 可以更智能地调度任务，确保高优先级任务得到及时响应。</li></ul></li> <li><p><strong>灵活性</strong>：</p> <ul><li>Fiber 提供了更灵活的更新机制，使得复杂的更新任务可以分块处理。</li></ul></li></ol> <hr> <h2 id="fiber-架构的核心实现"><a href="#fiber-架构的核心实现" class="header-anchor">#</a> <strong>Fiber 架构的核心实现</strong></h2> <p>以下是一个 Fiber 节点的示例实现：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">FiberNode</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">,</span> mode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>elementType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>dependencies <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h1 id="react-fiber-架构设计目标与特性"><a href="#react-fiber-架构设计目标与特性" class="header-anchor">#</a> React Fiber 架构设计目标与特性</h1> <h2 id="_1-设计目标不同"><a href="#_1-设计目标不同" class="header-anchor">#</a> <strong>1. 设计目标不同</strong></h2> <ul><li>React 的设计目标之一是实现任务的<strong>可中断和优先级调度</strong>。</li> <li>这需要复杂的调度机制和数据结构。</li> <li>双指针算法虽然简单高效，但无法满足 React 对任务调度和中断的需求。</li></ul> <hr> <h2 id="_2-灵活性要求"><a href="#_2-灵活性要求" class="header-anchor">#</a> <strong>2. 灵活性要求</strong></h2> <ul><li>React 希望在组件树结构中具有更高的灵活性，尤其是在处理复杂更新时。</li> <li>Fiber 架构允许 React 将复杂的更新任务分块处理，并在必要时中断和恢复。</li></ul> <hr> <h2 id="_3-可扩展性"><a href="#_3-可扩展性" class="header-anchor">#</a> <strong>3. 可扩展性</strong></h2> <ul><li>Fiber 架构构建未来优化和功能扩展的基础。</li> <li>使 React 可以更轻松地引入新的特性和优化。</li></ul> <h2 id="react如何实现自身的事件系统-什么叫合成事件"><a href="#react如何实现自身的事件系统-什么叫合成事件" class="header-anchor">#</a> React如何实现自身的事件系统？什么叫合成事件？</h2> <h1 id="react-合成事件-syntheticevent-详解"><a href="#react-合成事件-syntheticevent-详解" class="header-anchor">#</a> React 合成事件 (SyntheticEvent) 详解</h1> <h2 id="简介-4"><a href="#简介-4" class="header-anchor">#</a> <strong>简介</strong></h2> <p>React 合成事件 (<code>SyntheticEvent</code>) 是 React 框架自己实现的一套事件系统。<br>
它在系统模拟了原生的 DOM 事件，同时提供了一些额外的优点。</p> <hr> <h2 id="react-合成事件的特点"><a href="#react-合成事件的特点" class="header-anchor">#</a> <strong>React 合成事件的特点</strong></h2> <ol><li><p><strong>跨浏览器兼容性</strong>：</p> <ul><li>不同浏览器的原生事件行为可能存在差异。</li> <li>React 的合成事件为所有浏览器提供了一致的 API 和行为，从而消除了这种差异。</li></ul></li> <li><p><strong>性能优化</strong>：</p> <ul><li>React 使用了事件委托（Event Delegation）机制。</li> <li>所有事件都绑定到统一的顶层 DOM 节点，而不是直接绑定到组件的 DOM 节点。</li> <li>当事件发生时，React 会根据内部机制定位真正的事件处理器，这可以有效减少事件监听的数量，节省内存并提升性能。</li></ul></li> <li><p><strong>集成到 React 的状态系统</strong>：</p> <ul><li>React 的合成事件与 React 的状态更新机制深度集成。</li> <li>比如在事件回调中调用 <code>setState</code>，React 会正确地批处理更新和重新渲染。</li></ul></li> <li><p><strong>提供更多的信息</strong>：</p> <ul><li>React 的合成事件提供了比原生事件更多的信息，例如 <code>event.target</code>。</li></ul></li></ol> <hr> <h2 id="与原生-dom-事件的对比"><a href="#与原生-dom-事件的对比" class="header-anchor">#</a> <strong>与原生 DOM 事件的对比</strong></h2> <ul><li>React 合成事件的名称（如 <code>onClick</code>、<code>onChange</code>）和它们在组件中的使用方式，与 JavaScript 中使用 DOM 事件的方式非常相似。</li> <li>实际上，大多数情况下，你可以把它们当作标准的 DOM 事件来使用。</li></ul> <hr> <h2 id="特殊情况"><a href="#特殊情况" class="header-anchor">#</a> <strong>特殊情况</strong></h2> <ul><li>在 React 组件中，对于大多数事件来说，React 会将它们绑定到顶层 DOM 节点。</li> <li>相反，React 会直接在 <code>document</code> 节点上为每种事件类型附加一个处理器。</li> <li>除了在大型应用程序中处理性能问题外，这还通过 <code>Replaying Events</code> 这样的特性提供了更多的功能。</li></ul> <p>如果组件上有多个 React 版本，它们都会注册自己的事件处理器。这意味着即使调用 <code>stopPropagation()</code>，该组件树中的其他事件处理器仍然会接收到它。这会不同于原生 DOM 的事件传播模型。</p> <hr> <h2 id="react-17-的改进"><a href="#react-17-的改进" class="header-anchor">#</a> <strong>React 17 的改进</strong></h2> <ul><li>从 React 17 开始，React 不再将事件处理器附加到 <code>document</code> 上，而是将事件处理器附加到 React 树的根 DOM 容器中。</li></ul> <p>示例代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>ReactDom<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;app&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

ReactDom<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Header <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;header&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

ReactDom<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Footer <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;footer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="react-concurrent-mode是什么-react18是怎么实现的-他和usetransition有联系么"><a href="#react-concurrent-mode是什么-react18是怎么实现的-他和usetransition有联系么" class="header-anchor">#</a> React Concurrent Mode是什么？React18是怎么实现的？他和useTransition有联系么？</h2> <h2 id="答案"><a href="#答案" class="header-anchor">#</a> <strong>答案</strong></h2> <h3 id="react-concurrent-mode-的定义"><a href="#react-concurrent-mode-的定义" class="header-anchor">#</a> <strong>React Concurrent Mode 的定义</strong></h3> <ul><li>React 的 Concurrent Mode 是一种新的渲染模式。</li> <li>它使 React 能够在多个状态更新中进行<strong>时间切片</strong>，从而使得长时间运行的渲染任务不会阻塞浏览器的主线程。</li> <li>这种模式可以提高应用的响应性，特别是在复杂应用中用户界面较复杂的情况下。</li></ul> <hr> <h3 id="传统同步渲染-vs-concurrent-mode"><a href="#传统同步渲染-vs-concurrent-mode" class="header-anchor">#</a> <strong>传统同步渲染 vs Concurrent Mode</strong></h3> <ul><li><p>在传统的同步渲染中：</p> <ul><li>React 会在一个状态更新发生时阻塞主线程，直到所有的组件都渲染完成。</li> <li>在某些情况下，这可能会导致应用变得不够响应，因为主线程在渲染过程中无法处理其他任务，比如用户输入或动画。</li></ul></li> <li><p>在 Concurrent Mode 中：</p> <ul><li>React 会将任务拆分为多个小任务。</li> <li>每个任务的执行时间都很短，在这些任务之间，React 会给出一些空间的时间，让浏览器有机会处理其他的任务。</li> <li>这就是所谓的<strong>时间切片（Time Slicing）</strong>。</li></ul></li></ul> <hr> <h3 id="usetransition-的作用"><a href="#usetransition-的作用" class="header-anchor">#</a> <strong>useTransition 的作用</strong></h3> <ul><li><code>useTransition</code> 是 React 18 中引入的一个 Hook。</li> <li>它与 Concurrent Mode 紧密相关，<code>useTransition</code> 使你可以告诉 React：
<ul><li><strong>某些状态更新可能需要一些时间准备数据</strong>（例如发起一个网络请求）。</li> <li><strong>可以延迟更新的 UI</strong>，而不是立即渲染一个加载中的状态。</li> <li>这样可以避免界面的抖动，提升用户体验。</li></ul></li></ul> <hr> <h3 id="usetransition-在-concurrent-mode-中的使用"><a href="#usetransition-在-concurrent-mode-中的使用" class="header-anchor">#</a> <strong>useTransition 在 Concurrent Mode 中的使用</strong></h3> <ul><li>在 Concurrent Mode 中，<code>useTransition</code> 可以让你为应用在等待的数据期间的加载动画提供平滑的过渡，同时改善整体平滑的过渡界面效果。</li> <li>需要注意的是：
<ul><li>Concurrent Mode 和 <code>useTransition</code> 都是 React 18 中的特性。</li></ul></li></ul> <hr> <h3 id="总结-4"><a href="#总结-4" class="header-anchor">#</a> <strong>总结</strong></h3> <p>React Concurrent Mode 和 <code>useTransition</code> 是 React 18 中的重要功能，它们相辅相成，共同提高了复杂应用的用户体验和渲染性能。</p> <h2 id="将-vue-替换为-react-react-能提高-fps-吗-请给出理由"><a href="#将-vue-替换为-react-react-能提高-fps-吗-请给出理由" class="header-anchor">#</a> 将 Vue 替换为 React，React 能提高 FPS 吗？请给出理由</h2> <h3 id="答案-2"><a href="#答案-2" class="header-anchor">#</a> <strong>答案</strong></h3> <p>将 Vue 替换为 React，或反之，并不一定会提高应用的帧率（FPS）。<br>
实际的性能表现取决于许多因素，包括但不限于：</p> <ul><li>你如何使用这些框架。</li> <li>你的应用的具体需求。</li> <li>用户的设备性能。</li></ul> <p>React 和 Vue 在设计上有一些关键的不同，这些不同可能会影响它们在特定场景下的性能：</p> <hr> <h4 id="_1-虚拟-dom-实现"><a href="#_1-虚拟-dom-实现" class="header-anchor">#</a> <strong>1. 虚拟 DOM 实现</strong></h4> <ul><li>React 和 Vue 都使用虚拟 DOM 来提升渲染性能，但它们的实现方式略有不同。</li> <li>Vue 在某些情况下可以跳过依赖关系，更新改动的部分，而不是重新渲染整个组件树。</li> <li>React 从 15+ 版本起引入了一些优化技巧，例如 <code>shouldComponentUpdate</code> 和 <code>React.memo</code>，开发者可以用它们来避免不必要的渲染。</li></ul> <hr> <h4 id="_2-异步渲染"><a href="#_2-异步渲染" class="header-anchor">#</a> <strong>2. 异步渲染</strong></h4> <ul><li>React 的 Concurrent Mode 和 <code>useTransition</code> Hook 支持异步渲染。</li> <li>这可以让 React 在处理大量更新时保持界面的响应，特别是存在用户交互时。</li> <li>Vue 在此部分没有类似的特性，但它在某些需求场景表现足够优化。</li></ul> <hr> <h3 id="_3-框架的大小"><a href="#_3-框架的大小" class="header-anchor">#</a> <strong>3. 框架的大小</strong></h3> <ul><li>React 和 Vue 的框架大小相近，但 Vue 的模板编译器通常会稍微占用更多的时间。</li> <li>React 的组件设计更灵活，优化代码路径清晰，而 Vue 的响应式特性可能增加额外的开销。</li></ul> <hr> <h3 id="总结-5"><a href="#总结-5" class="header-anchor">#</a> <strong>总结</strong></h3> <ul><li>从一个框架迁移到另一个框架需要大量工作，并且可能带来不必要的维护成本。</li> <li>如果你使用 Vue 的现有组件，优化核心模块，或使用 Webpack 进行代码分割，通常可以达到类似的性能提升效果。</li> <li>提高 FPS 关键在于优化你的代码和框架的使用，而非更换框架本身。</li></ul> <h2 id="lane-是什么-解决了-react-什么问题-原理是什么"><a href="#lane-是什么-解决了-react-什么问题-原理是什么" class="header-anchor">#</a> Lane 是什么？解决了 React 什么问题，原理是什么？</h2> <h3 id="答案-3"><a href="#答案-3" class="header-anchor">#</a> <strong>答案</strong></h3> <h4 id="react-17-的-lanes-模型和-concurrent-mode"><a href="#react-17-的-lanes-模型和-concurrent-mode" class="header-anchor">#</a> <strong>React 17 的 lanes 模型和 Concurrent Mode</strong></h4> <ul><li>React 17 的 lanes 模型和 Concurrent Mode 都是为了更好地支持 React Suspense。</li> <li>它们可以一起更好地处理复杂的异步更新和任务调度。</li></ul> <hr> <h4 id="在-react-16-中的局限性"><a href="#在-react-16-中的局限性" class="header-anchor">#</a> <strong>在 React 16 中的局限性</strong></h4> <ul><li>即使启用了 Concurrent Mode 的情况下，Suspense 在某些情况下表现得不够理想。</li> <li>当多个 Suspense 组件同时进行数据加载时，它们可能会阻塞彼此，甚至阻塞整个应用，直到所有的数据都加载完成。</li> <li>这种情况可能会导致不必要的渲染延迟和用户体验下降。</li></ul> <hr> <h4 id="react-17-中的改进"><a href="#react-17-中的改进" class="header-anchor">#</a> <strong>React 17 中的改进</strong></h4> <ul><li>React 17 引入了 lanes 模型：
<ul><li>React 可以智能地处理并调度各种不同的更新。</li> <li>Suspense 组件的加载和渲染可以被分配到不同的 lane 上。</li> <li>这样可以让 React 更好地管理和调度任务。</li></ul></li> <li>对于那些被 Suspense 捕获的异步更新，React 可以暂时将它们推迟，优先处理其他更重要或优先级更高的更新。</li> <li>这可以提升应用的响应速度和性能。</li></ul> <hr> <h3 id="总结-6"><a href="#总结-6" class="header-anchor">#</a> <strong>总结</strong></h3> <p>Lanes 模型是 React 17 的重要改进之一，它解决了 Suspense 和异步更新在复杂场景中的调度问题，为应用提供了更高效的任务管理能力。</p> <h2 id="react-fiernode链表伪代码"><a href="#react-fiernode链表伪代码" class="header-anchor">#</a> React  FierNode链表伪代码</h2> <ul><li>，在编程和数据结构中，链表是一种基碰的数据结构类型。它由一系列的节点组成，每个节点包含数据和执行下一个节点的引用。以下是一个简单的链表节点的 JavsScnpt 实现:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">class</span> <span class="token class-name">Listiode</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>在这个 <strong>listNode</strong> 类中， data 属性用于存储节点的数据, <strong>next</strong> 属性用于存储对下一个节点的引用。当 next 为 ho11 时，表示这是链表的末尾。</p></li> <li><p>在 React 的 <strong>Fiber</strong> 架构中，<strong>Fiber</strong> 节点就形成了一种类似链表的数据结构。每个 <strong>Fiber</strong> 节点都有一个 chi1d 属性和一个 <strong>sibling</strong> 属性，它们分别用于引用该节点的第一个子节点和下一个兄弟节点。以下是一个简化的示意代码:</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Listiode</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span>  <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 父节点</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个 <strong>FiberNode</strong> 类中， <strong>component</strong> 属性用于存储节点的组件数据，<strong>child</strong> 属性用于存储对第一个子节点的引用， <strong>sibling</strong> 属性用于存储对下一个兄弟节点的引用。return 属性则是对父节点的引用。通过这种方式，React构建了一个 Fiber 树，其中的每个节点都可以通过链表的方式访问其子节点和兄弟节点。这种数据结构使得 React 能够有效地遍历和渲染组件树。</p> <h2 id="react-scheduler-涉及到核心微任务-宏任务代码输出"><a href="#react-scheduler-涉及到核心微任务-宏任务代码输出" class="header-anchor">#</a> React Scheduler 涉及到核心微任务，宏任务代码输出</h2> <h2 id="react-dom-diff-原理"><a href="#react-dom-diff-原理" class="header-anchor">#</a> React Dom Diff 原理？</h2> <h3 id="答案-4"><a href="#答案-4" class="header-anchor">#</a> <strong>答案</strong></h3> <p>React DOM Diff 可以分为以下 4 种情况：</p> <ol><li><p><strong>key 相同，type 相同</strong>：</p> <ul><li>复用当前节点。</li> <li>示例：<code>A1 B2 C3 -&gt; A1</code></li></ul></li> <li><p><strong>key 相同，type 不同</strong>：</p> <ul><li>不存在任何复用的可能性。</li> <li>示例：<code>A1 B2 C3 -&gt; B1</code></li></ul></li> <li><p><strong>key 不同，type 相同</strong>：</p> <ul><li>当前节点不能复用。</li></ul></li> <li><p><strong>key 不同，type 不同</strong>：</p> <ul><li>当前节点不能复用。</li></ul></li></ol> <hr> <h3 id="算法核心步骤"><a href="#算法核心步骤" class="header-anchor">#</a> <strong>算法核心步骤</strong></h3> <p>React Diff 的核心流程包含以下步骤：</p> <ol><li>将 <code>current</code> 阶段所有的 <code>fiber</code> 保存到 Map 中。</li> <li>遍历 <code>newChild</code> 列表，对于每个遍历到的 <code>element</code>，存在两种情况：
<ul><li><strong>Map 中存在对应的 <code>current fiber</code></strong>：可以复用。</li> <li><strong>Map 中不存在对应的 <code>current fiber</code></strong>：不能复用。</li></ul></li> <li>处理新增节点。</li> <li>Map 中剩余未匹配的节点将被删除。</li></ol> <h2 id="react-的同构开发你是如何部署的-使用-next-js-还是自己开发好-流式渲染是什么有什么好处"><a href="#react-的同构开发你是如何部署的-使用-next-js-还是自己开发好-流式渲染是什么有什么好处" class="header-anchor">#</a> React 的同构开发你是如何部署的？使用 Next.js 还是自己开发好？流式渲染是什么有什么好处？</h2> <h3 id="答案-5"><a href="#答案-5" class="header-anchor">#</a> <strong>答案</strong></h3> <p>React 的同构开发（Isomorphic JavaScript）是一种将 React 代码能够在服务端执行并生成 HTML，然后在浏览器端接管渲染并进一步交互的开发方式。<br>
这样的优点包括：</p> <ol><li><p><strong>提升首屏渲染速度</strong>：</p> <ul><li>加强用户体验，特别是在网络较慢或设备性能有限的情况下。</li></ul></li> <li><p><strong>对搜索引擎优化（SEO）有利</strong>：</p> <ul><li>因为搜索引擎可以直接解析服务端返回的 HTML 内容，而无需额外执行 JavaScript。</li></ul></li></ol> <hr> <h3 id="关于部署方式"><a href="#关于部署方式" class="header-anchor">#</a> <strong>关于部署方式</strong></h3> <p>常见的部署方式有以下两种：</p> <ol><li><p><strong>使用 Next.js</strong></p> <ul><li>Next.js 是一个流行的、基于 React 的同构 JavaScript 框架。</li> <li>它能处理常见的开发问题，包括路由器、数据预取和预渲染等。</li> <li>使用 Next.js 通常可以节省大量开发时间，并提供了一个成熟稳定的平台。</li></ul></li> <li><p><strong>自己开发</strong></p> <ul><li>这种方式使用 Node.js 服务端框架（如 Express）来构建 React 应用。</li> <li>服务端发送生成的 HTML 到浏览器。</li> <li>这种方式需要解决较多细节问题，例如代码分割、数据预取和路由配置。</li></ul></li></ol> <hr> <h3 id="云平台的选择"><a href="#云平台的选择" class="header-anchor">#</a> <strong>云平台的选择</strong></h3> <p>可以参考以下云平台来部署：</p> <ul><li>AWS</li> <li>Cloudflare</li></ul> <p>在部署同构应用时，常见实践是结合反向代理（如 Nginx），将特定请求转发到 Node.js 服务端完成渲染。</p> <hr> <h3 id="关于流式渲染"><a href="#关于流式渲染" class="header-anchor">#</a> <strong>关于流式渲染</strong></h3> <ul><li>流式渲染（streaming）是一种按需发送数据的模式。</li> <li>不等待完整内容生成后一次性发送，而是逐步将生成的内容发送给用户。</li> <li><strong>优点</strong>：
<ol><li><strong>提高渲染速度</strong>：用户可以更早地看到部分渲染的页面。</li> <li><strong>节省服务器内存</strong>：因为无需将完整的 HTML 存在内存中，可以直接将内容流式发送给用户。</li></ol></li></ul> <hr> <h3 id="总结-7"><a href="#总结-7" class="header-anchor">#</a> <strong>总结</strong></h3> <p>如果你需要快速开发，推荐使用 Next.js；如果需要完全自定义和掌控，自己开发也是可行的选择。
流式渲染可以显著提升用户体验，是优化大型应用性能的重要技术。</p> <p>bigpip</p> <h2 id="react-服务端渲染需要进行-hydrate-吗-哪些版本不需要-我听说-qwik-是懒加载的-为什么呢"><a href="#react-服务端渲染需要进行-hydrate-吗-哪些版本不需要-我听说-qwik-是懒加载的-为什么呢" class="header-anchor">#</a> React 服务端渲染需要进行 Hydrate 吗？哪些版本不需要？我听说 Qwik 是懒加载的，为什么呢？</h2> <h3 id="答案-6"><a href="#答案-6" class="header-anchor">#</a> <strong>答案</strong></h3> <h4 id="react-的-hydrate-概念"><a href="#react-的-hydrate-概念" class="header-anchor">#</a> <strong>React 的 Hydrate 概念</strong></h4> <ul><li>在 React 服务端渲染（Server Side Rendering, SSR）中，<code>hydrate</code> 是一个重要的步骤。</li> <li>React 会生成 HTML 字符串，然后在浏览器端，React 需要接管这些已经渲染好的 HTML，使其可以交互。</li> <li>这个过程称为 <code>hydration</code>。</li></ul> <hr> <h4 id="从-react-16-开始"><a href="#从-react-16-开始" class="header-anchor">#</a> <strong>从 React 16 开始</strong></h4> <ul><li>React 引入了 <code>ReactDOM.hydrate</code> 来替代 <code>ReactDOM.render</code> 进行 <code>hydration</code>。</li> <li>如果你在服务端渲染了某些内容，然后想在客户端接管这个根上，你需要使用 <code>ReactDOM.hydrate</code> 而不是 <code>ReactDOM.render</code>。</li></ul> <hr> <h4 id="react-18-的改进"><a href="#react-18-的改进" class="header-anchor">#</a> <strong>React 18 的改进</strong></h4> <ul><li>React 18 开始计划引入部分懒加载的 <code>hydration</code>。</li> <li><strong>部分 <code>hydration</code> 的主要思想</strong>：
<ul><li>React 应用在初始渲染时并不立即 <code>hydrate</code> 全部组件，而是根据用户的交互行为分阶段加载和执行。</li> <li>这提升了用户体验，尤其是在页面复杂度较高时。</li></ul></li></ul> <hr> <h4 id="关于-qwik"><a href="#关于-qwik" class="header-anchor">#</a> <strong>关于 Qwik</strong></h4> <ul><li>Qwik 是 Google 推出的一种面向性能优化的 JavaScript 框架。</li> <li>Qwik 的设计目标是提供“即用即执行”的性能。</li> <li>为了实现这一目标，Qwik 采用了一种称为 <strong>“HTML-oriented programming”</strong> 的方法：
<ol><li>Qwik 将组件的 HTML 作为静态内容直接发送到浏览器，并将事件处理器等 JavaScript 按需加载。</li> <li>Qwik 能够暂停和恢复 JavaScript 的执行，而无需加载完整的前端代码。</li></ol></li></ul> <hr> <h4 id="qwik-的优点"><a href="#qwik-的优点" class="header-anchor">#</a> <strong>Qwik 的优点</strong></h4> <ol><li><p><strong>按需加载</strong>：</p> <ul><li>与传统框架不同，Qwik 不需要完整加载 HTML 以完成渲染，而是通过 diff 和 <code>hydration</code> 来精确加载用户所需的部分内容。</li></ul></li> <li><p><strong>极快的首屏渲染</strong>：</p> <ul><li>Qwik 可以显著减少页面的 HTML 解析和加载时间，特别是针对首字节渲染（First Contentful Paint, FCP）优化。</li></ul></li></ol> <hr> <h4 id="总结-8"><a href="#总结-8" class="header-anchor">#</a> <strong>总结</strong></h4> <ul><li><p>React 的 <code>hydrate</code> 是服务端渲染的重要步骤，部分版本（如 React 18）开始尝试部分 <code>hydration</code>。</p></li> <li><p>Qwik 的“HTML-oriented programming”方法通过按需加载显著优化了单页应用（SPA）的性能，非常适合高性能要求的场景。</p></li></ul> <p>面试4 ------ web相关的 可以再次回顾
面试5 ------ web相关的 可以再次回顾</p> <h2 id="react-同构渲染如何提高性能问题-都有哪些关键指标-同构解决了哪些性能指标"><a href="#react-同构渲染如何提高性能问题-都有哪些关键指标-同构解决了哪些性能指标" class="header-anchor">#</a> React 同构渲染如何提高性能问题？都有哪些关键指标？同构解决了哪些性能指标？</h2> <h3 id="答案-7"><a href="#答案-7" class="header-anchor">#</a> <strong>答案</strong></h3> <p>React 同构渲染，也称为服务端渲染（SSR），在某些情况下可以极大地提高性能，并改善用户体验。以下是其可能的性能优势：</p> <h4 id="_1-提升首屏加载速度"><a href="#_1-提升首屏加载速度" class="header-anchor">#</a> <strong>1. 提升首屏加载速度</strong></h4> <ul><li>SSR 会将 React 应用的初始状态渲染为 HTML，然后发送到客户端。</li> <li>这样浏览器可以更早地开始显示页面内容，而不用等待所有的 JavaScript 代码下载、解析和执行。</li></ul> <h4 id="_2-对-seo-友好"><a href="#_2-对-seo-友好" class="header-anchor">#</a> <strong>2. 对 SEO 友好</strong></h4> <ul><li>搜索引擎更容易抓取和解析服务端返回的 HTML，而不是客户端渲染的 JavaScript。</li></ul> <hr> <h3 id="关键性能指标"><a href="#关键性能指标" class="header-anchor">#</a> <strong>关键性能指标</strong></h3> <p>一般可以从以下指标评估加载性能如何影响用户体验：</p> <ol><li><p><strong>FCP (First Contentful Paint)</strong>：</p> <ul><li>首次内容绘制，SSR 可以减少 FCP 的时间，因为用户可以在收到服务器返回的 HTML 后立即开始渲染页面。</li></ul></li> <li><p><strong>FMP (First Meaningful Paint)</strong>：</p> <ul><li>首次有意义绘制，SSR 也可以减少 FMP 的时间，因为服务器渲染的页面通常包含了页面的主要内容。</li></ul></li> <li><p><strong>LCP (Largest Contentful Paint)</strong>：</p> <ul><li>最大内容绘制，LCP 测量页面的主要内容（通常是标题或主要图片）从用户视角可见的时间。</li></ul></li> <li><p><strong>FID (First Input Delay)</strong>：</p> <ul><li>首次输入延迟，FID 测量从用户交互（例如点击按钮）到浏览器开始处理交互之间的时间。</li></ul></li> <li><p><strong>CLS (Cumulative Layout Shift)</strong>：</p> <ul><li>累积布局偏移，CLS 测量由于内容重新布局而造成的页面视觉稳定性问题。</li></ul></li></ol> <hr> <h3 id="如何优化"><a href="#如何优化" class="header-anchor">#</a> <strong>如何优化</strong></h3> <p>为了进一步提升性能，可以在部署中结合以下技术：</p> <ol><li><p><strong>数据预取</strong>：</p> <ul><li>使用适当的数据加载方法（如 <code>loadData</code> 方法），或者使用 Next.js 提供的解决方案。</li></ul></li> <li><p><strong>客户端优化</strong>：</p> <ul><li>服务器渲染后应尽可能减少额外的重新渲染工作，例如避免多次调用 <code>componentDidMount</code> 和 <code>componentDidUpdate</code>。</li></ul></li> <li><p><strong>服务器优化</strong>：</p> <ul><li>提高服务器的计算性能（CPU 和内存管理），并通过代码拆分和缓存来降低负载。</li></ul></li></ol> <hr> <h3 id="总结-9"><a href="#总结-9" class="header-anchor">#</a> <strong>总结</strong></h3> <p>React 的 SSR 不仅能优化 Web 的核心性能指标，还能提高用户体验。如果需要快速实现这些功能，可以使用 Next.js，它为 React SSR 提供了极大的便利。</p> <h2 id="各个平台进行-javascript-冷启动的区别是什么"><a href="#各个平台进行-javascript-冷启动的区别是什么" class="header-anchor">#</a> 各个平台进行 JavaScript 冷启动的区别是什么？</h2> <h3 id="答案-8"><a href="#答案-8" class="header-anchor">#</a> <strong>答案</strong></h3> <h4 id="_1-cloudflare-workers-与-aws-lambda-的对比"><a href="#_1-cloudflare-workers-与-aws-lambda-的对比" class="header-anchor">#</a> <strong>1. Cloudflare Workers 与 AWS Lambda 的对比</strong></h4> <ul><li><p><strong>Cloudflare Workers</strong>:</p> <ul><li>基于 Google V8 Isolate 引擎的轻量级隔离环境。</li> <li>每个请求都会在一个新的 Isolate 中执行，每个 Isolate 都拥有自己的高密度隔离和数据传输。</li> <li>创建和销毁的开销非常低，这使得 Cloudflare Workers 在冷启动时间方面表现极为优异。</li></ul></li> <li><p><strong>AWS Lambda</strong>:</p> <ul><li>使用不同的隔离方式，比 Cloudflare Workers 更为重量级。</li> <li>每当 Lambda 函数冷启动时，需要加载和初始化运行环境，启动时间通常更长。</li> <li>频繁使用的函数通常会有较好的性能，因为热启动减少了初始化时间。</li></ul></li></ul> <hr> <h4 id="_2-javascript-函数冷启动分析"><a href="#_2-javascript-函数冷启动分析" class="header-anchor">#</a> <strong>2. JavaScript 函数冷启动分析</strong></h4> <ul><li><p><strong>AWS Lambda 使用 Node.js 环境</strong>：</p> <ul><li>在该环境中，函数首次被调用时需要初始化，这个过程会花费一定时间。</li> <li>冷启动需要计算资源加载函数代码、依赖项及其初始化状态。</li> <li>对于大型函数或复杂依赖项，冷启动时间可能会更长。</li></ul></li> <li><p><strong>Cloudflare Workers</strong>:</p> <ul><li>由于基于 V8 Isolate，启动开销非常小。</li> <li>可以快速完成环境加载和代码执行。</li></ul></li></ul> <hr> <h4 id="_3-总结"><a href="#_3-总结" class="header-anchor">#</a> <strong>3. 总结</strong></h4> <ul><li><p><strong>Cloudflare Workers</strong>:</p> <ul><li>适合需要快速响应的小型任务，冷启动时间极短。</li></ul></li> <li><p><strong>AWS Lambda</strong>:</p> <ul><li>适合更复杂的场景，提供更大的灵活性，但冷启动时间较长。</li></ul></li></ul> <p>两者各有优势，具体选择取决于应用场景和对性能的需求。</p> <h2 id="同构注水与脱水是什么意思-react-进行-serverless-部署时项目实现效果是否变化"><a href="#同构注水与脱水是什么意思-react-进行-serverless-部署时项目实现效果是否变化" class="header-anchor">#</a> 同构注水与脱水是什么意思？React 进行 Serverless 部署时项目实现效果是否变化？</h2> <h3 id="答案-9"><a href="#答案-9" class="header-anchor">#</a> 答案</h3> <p>React 项目渲染涉及到“注水”和“脱水”的概念。这两个术语来源于 React 服务端渲染（SSR）的两个重要步骤：</p> <ol><li><p><strong>脱水 (Dehydration)</strong>：
在服务端渲染时，React 将组件渲染为 HTML 字符串，并生成与应用状态相关的快照（即“脱水”数据）。然后，服务端将渲染后的 HTML 和快照数据一起发送到客户端。</p></li> <li><p><strong>注水 (Rehydration)</strong>：
在客户端，React 使用服务端发送过来的快照数据恢复应用的状态，这个过程被称为“注水”。然后 React 会将服务端渲染的 HTML 和客户端组件树进行匹配。如果匹配成功，React 将管理已经存在的 DOM 组件，而无需重新渲染。</p></li></ol> <hr> <h3 id="说明"><a href="#说明" class="header-anchor">#</a> 说明</h3> <p>这种同构渲染方式有以下好处：</p> <ul><li>首先，用户可以更快速地看到页面内容，因为浏览器可以直接渲染已经生成好的 HTML。</li> <li>其次，由于服务端渲染生成的内容，客户端能更快地完成渲染。</li> <li>最后，React 的“注水”机制允许接管已有的 DOM，避免了额外的 DOM 操作，从而提高了性能。</li></ul> <p>但需要注意，这种方式在一些场景下可能会遇到问题，例如服务端和客户端可能会出现一些误差，如数据不一致导致错误的状态。</p> <hr> <p>具体的 Next.js 部署请参考官方文档：<a href="https://developers.cloudflare.com/pages/framework-guides/deploy-a-nextjs-site/" target="_blank" rel="noopener noreferrer">https://developers.cloudflare.com/pages/framework-guides/deploy-a-nextjs-site/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <!----> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/font-end-nodes/interview/types/26-自定义SSR.html" class="prev">
        自定义SSR
      </a></span> <span class="next"><a href="/font-end-nodes/interview/types/28-面试小册子.html">
        前端面试小册子
      </a>
      →
    </span></p></div>  <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="dialog" class="el-dialog" style="margin-top:15vh;width:420px;"><div class="el-dialog__header"><span class="el-dialog__title"></span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><div class="el-dialog__footer"><span class="dialog-footer"><button type="button" class="el-button el-button--default"><!----><!----><span>取 消</span></button> <button type="button" class="el-button el-button--primary"><!----><!----><span>确 定</span></button></span></div></div></div></main> <!----></div><div class="global-ui"><!----></div></div>
    <script src="/font-end-nodes/assets/js/app.832bd39e.js" defer></script><script src="/font-end-nodes/assets/js/2.a07749b4.js" defer></script><script src="/font-end-nodes/assets/js/1.80701c87.js" defer></script><script src="/font-end-nodes/assets/js/232.24744b96.js" defer></script>
  </body>
</html>
