---
sidebarDepth: 10
---

# 性能优化 

## 网页时如何加载并渲染出来的

:::tip
- DNS解析：域名->IP地址 （domain name serve 域名服务解析）
- 浏览器根据IP地址向服务器发起http请求
- 服务器处理http请求，并返回给浏览器
- 根据Html 代码生成DOM tree 
- 根据css 代码更生CSSOM
- 根据Render Tree 渲染页面
- 遇到script 则暂停渲染，优先加载并执行js代码，完成再继续
:::

![网页时如何加载并渲染出来的](./assets/xn.png)

## 前端性能优化有哪些方式
### 性能优化原则
:::tip
- 多使用内存、缓存或其他方法
- 减少CPU计算量，减少网络加载耗时
- 空间换时间
:::
### 加载更快
:::tip
- 减少资源体积：压缩代码 
- 减少访问次数：合并代码 ，SSR 服务器渲染，缓存
- 使用更快的网络：CDN
:::
### 渲染更快
:::tip
- css放在head，js放在body最下面
- 尽早执行js，用DOMContentLoaded触发 
- 懒加载 （图片懒加载，上滑懒加载）
- 对DOM查询进行缓存
- 频繁DOM操作，合并到一起插入DOM结构
- 节流 防抖 
:::

## 前端性能优化示例
## 手写debounce
## 手写throttle 
## 如何预防xss攻击
## 如何预防xsf攻击


 ## 节流和防抖
 :::tip
 **防抖**
 - 防抖，防止抖动，‘你先抖动着，啥时候停，再执行下一步’
 - 比如：一个输入框，等输入停了，在执行下一步
 :::
 ```js
 function debounce(fn, delay = 500) {
    // timer 是闭包中的
    let timer = null

    return function () {
        if (timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}
 ```
 ![alt text](./assets/fd.png)
 :::tip
 **节流**
 - 节流，节省交互沟通。流，不一定指流量
 - 别急，一个一个来，按节奏来，插队者无效
 - 例如，drag或scroll 期间触发回调
 :::
 ```js
 // 节流
function throttle(fn, delay = 100) {
    let timer = null

    return function () {
        if (timer) {
            return
        }
        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}

div1.addEventListener('drag', throttle(function (e) {
    console.log(e.offsetX, e.offsetY)
}))

div1.addEventListener('drag', function(event) {

})

 ```
 ![alt text](./assets/throttle.png)

## px % em rem vw/vh 有什么区别
:::tip
- px基本单位，绝对单位（其他都是相对单位）
- vw屏幕宽度的1%
- vh屏幕高度的1%
- vmin 两者的最小值，vmax 两者的最大值
- em 相对于当前元素的font-size 
- rem 相对于跟节点的font-size 
:::
## 什么时候不能使用箭头函数
:::tip

**缺点**

- 改变不了this 
- 获取不到arguments

**不能使用的场景**

- 对象的方法 不能使用箭头函数
```js
     const obj = {
            name: '双越',
            getName: () => {
                return this.name
            }
        }
     const obj = {
            name: '双越',
            getName: (){
                return this.name
            }
        }    
```
- 原型方法不能使用箭头函数
```js
const obj = {
    name:'ljh'
}
obj.__proto__.getName: ()=>{
    return this.name
}
// obj.__proto__.getName = function(){
//     return this.name
// }
console.log(obj.getName())
```
- 构造函数 
```js
  class Foo {
        constructor(name, city) {
          this.name = name;
          this.city = city;
        }
        getName = () => {
          return this.name;
        };
      }
      const f = new Foo("ljh", "北京");
      console.log(f.getName());
```
- vue 生命周期和method
  - Vue 组件本质上是一个 JS 对象
  - React 组件（非 Hooks）它本质上是一个 ES6 class

![alt text](./assets/vuefn.png)

:::

## TCP三次握手和四次挥手 
:::tip
- 先建立连接（确保双方都有收发消息的能力）
  - client 发包，server 接收。server ：有client要找我
  - server 发包，client接收。client：server 已经接收消息
  - client 发包 ，server接收， server：client 要准备发送了 
- 在传输内容（如发送一个get请求）
- 网络连接TCP协议，传输内容是http协议
- 断开链接 
  - client 发包，server 接收。server ：client没有东西可以传输
  - serve 发包，client 接收。server ：ok
  - serve 发包，client 接收。server ：没有东西了
  - client 发包，server 接收。 serve 断开

![alt text](./assets/tcp.png)  
:::

## http 为何需要缓存
:::tip
- 加载页面更快些 
- 减少网络请求数量
- 哪些资源可以被缓存？ -- 静态资源（js css img）
:::

## cache-control是什么意思 - http强制缓存

:::tip
- 在Response Headers 中
- 控制强制缓存的逻辑
- Cache-Control：max-age / no- cache / no-store / private / public
:::

![alt text](./assets/catch.png)

![alt text](./assets/catch1.png)

![alt text](./assets/cache2.png)

## Etag和Last-Modified是什么意思(对比缓存)

:::tip
- 服务端缓存策略
- 服务端判断客户端资源，是否和服务端资源一样
- 如果一致返回304，否则返回200和最新的资源
:::

![alt text](./assets/modified.png)
:::tip
**资源标识**
- 在Response Headers 中，有两种
  - Last- Modified资源最后修改时间

  ![alt text](./assets/modified1.png)

  - Etag 资源的唯一标识（一个字符串，类似人类的指纹）

  ![alt text](./assets/etag.png)
- 优先使用Etag
- Last-Modified只能精确到秒级
- 如果资源被重复生成，而内容不变，则etag更精确  
:::
![alt text](./assets/header.png)
![alt text](./assets/etag2.png)
![alt text](./assets/etag3.png)
## for...in和for...of有什么区别
:::tip
- 遍历数组 字符串 
  - for...in 得到的是key
  - for...of 得到的是value 
- arguments
- 遍历对象：for...in可以，for...of 不可以
- 遍历Map Set：for...of 可以，for...in不可以
- 遍历generator：for...of可以， for...in 不可以
```js
     function fn() {
            for (let arg of arguments) {
                console.log(arg)
            }
        }
        fn(100, 200, 'aaa')
``` 
```js
const pList = document.querySelectorAll('p')
      for (let p of pList) {
          console.log(p)
      }

``` 
```js
  const obj = {
          name: '双越',
          city: '北京'
      }
      for (let val in obj) {
          console.log(val) 
      }

      const set = new Set([10, 20, 30])
      for (let n of set) {
          console.log(n)
      }

      const map = new Map([
          ['x', 100],
          ['y', 200],
          ['z', 300]
      ])
      for (let n of map) {
          console.log(n)
      }

      function* foo() {
          yield 10
          yield 20
          yield 30
      }
      for (let n of foo()) {
          console.log(n)
      }
```
:::

### 可枚举 VS 可迭代
:::tip
- for...in 用于可枚举数据，如对象，数组，字符串
- for...of 用于可迭代数据，如数组，字符串，Map Set
:::

## for await...of  有什么作用？
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>for-await-of</title>
</head>
<body>
    <p>for await of</p>

    <script>
        function createPromise(val) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(val)
                }, 1000)
            })
        }

        (async function () {
            // const p1 = createPromise(100)
            // const p2 = createPromise(200)
            // const p3 = createPromise(300)

            // // const res1 = await p1
            // // console.log(res1)
            // // const res2 = await p2
            // // console.log(res2)
            // // const res3 = await p3
            // // console.log(res3)

            // const list = [p1, p2, p3]
            // // Promise.all(list).then(res => console.log(res))
            // for await (let res of list) {
            //     console.log(res)
            // }

            // ---------------------- 分割线 ----------------------

            // const res1 = await createPromise(100)
            // console.log(res1)
            // const res2 = await createPromise(200)
            // console.log(res2)
            // const res3 = await createPromise(300)
            // console.log(res3)

            // const arr = [10, 20, 30]
            // for (let num of arr) {
            //     const res = await createPromise(num)
            //     console.log(res)
            // }
        })()
    </script>
</body>
</html>
```
## offsetHeight scrollHeight clientHeight
:::tip
- 计算规则
  - offetHeight offsetWidth：border+padding + content 
  - clientHeight clientWidth： padding + content 
  - scrollHeight scrollWidth： padding + 实际内容宽高
:::

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>offsetHeight</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        body {
            background-color: #f1f1f1;
        }

        #container {
            width: 300px;
            height: 200px;
            padding: 20px;
            margin: 30px;
            border: 5px solid #ccc;
            box-sizing: border-box;
            overflow: auto;
            background-color: #fff;
        }
        #content {
            width: 600px;
            height: 500px;
            background-color: #f1f1f1;
            display: inline-block;
        }
    </style>
</head>
<body>
    <p>offsetHeight</p>

    <div id="container">
        <div id="content">
            <p>offsetHeight scrollHeight clientHeight 区别</p>
        </div>
    </div>

    <script>
        const container = document.getElementById('container')
        console.log('offsetHeight', container.offsetHeight)
        console.log('offsetWidth', container.offsetWidth)
        console.log('clientWidth', container.clientWidth)
        console.log('clientHeight', container.clientHeight)
        console.log('scrollWidth', container.scrollWidth)
        console.log('scrollHeight', container.scrollHeight)

        // scrollTop scrollLeft 需滚动之后获取
    </script>
</body>
</html>
```

![alt text](./assets/box.png)

## HTMLCollection 和NodeList 区别
:::tip
- DOM是一棵树，所有节点都是Node
- Node是Element 的基类
- Element是其他HTML元素的基类，如HTMLDivElement
:::
![alt text](./assets/node.png)
:::tip
- 获取Node和Element的返回结果可能不一样
- 如elem.childNodes 和elem.children 不一样
- 前者会包含Text 和Comment节点，后者不会
:::
### 类数组->数组
![alt text](./assets/array.png)

## vue中computed和watch 区别 
:::tip
- computed 用于计算产生新的数据
- watch 用于监听现有的数据
:::

```vue
<template>
    <p>watch and computed</p>
    <p>姓名：<input v-model="name"> 城市：<input v-model="city"></p>
    <p>个人信息：{{userInfo}}</p>
</template>

<script>
export default {
    data() {
        return {
            name: '双越',
            city: '北京'
        }
    },
    watch: {
        name(newValue, oldValue) {
            console.log('watch name', newValue, oldValue)
        }
    },
    computed: {
        userInfo() {
            // 有缓存
            return this.name + this.city
        }
    },
    methods: {
        getUserInfo() {
            // 无缓存
            return this.name + this.city
        }
    },
}
</script>
```
## vue组件通讯方式
:::tip
- props和$emit
```vue
<template>
  <div class="home">
    <HelloWorld msg="Welcome to Your Vue.js App" @showMsg="showMsg"/> 
  </div>
</template>
<script>
// import HelloWorld from '@/components/HelloWorld.vue'
import ErrorDemo from '@/components/ErrorDemo'

export default {
  name: 'Home',
  components: {
    HelloWorld,
   
  },
  methods: {
    showMsg(msg) {
      console.log(msg)
    }
  },
}
</script>

```
```vue
<template>
  <h1 @click="clickHandler">{{ msg }}</h1>
</template>

<script>
export default {
  name: 'HelloWorld',
  props: {
    msg: String
  },
  emits: ['showMsg'], // Vue3
  data() {
    return {
      name: 'hello-world'
    }
  },
  methods: {
    clickHandler() {
      this.$emit('showMsg', 'hello world')
    }
  },
}
</script>

```
- 自定义事件
```vue
<template>
  <p>receive custom event</p>
</template>

<script>
import event from '../utils/event.js'

export default {
  name: 'CustomEvent1',
  methods: {
    showMsg(msg) {
      console.log(msg)
    }
  },
  mounted() {
    event.on('showMsg', this.showMsg)
  },
  // Vue2.x beforeDestroy
  beforeUnmount() {
    event.off('showMsg', this.showMsg)
  },
}
</script>
```
```vue
<template>
  <p><button @click="trigger">trigger custom event</button></p>
</template>

<script>
import event from '../utils/event.js'

export default {
  name: 'CustomEvent2',
  methods: {
    trigger() {
      event.emit('showMsg', 'hello custom event')
    }
  },
}
</script>

```
- $attr
**Level1:**
```vue
<template>
    <p>Level1</p>
    <Level2
        :a="a"
        :b="b"
        :c="c"
        @getA="getA" 
        @getB="getB"
        @getC="getC"
    ></Level2>
</template>

<script>
import Level2 from './Level2'

export default {
    name: 'Level1',
    components: { Level2 },
    data() {
        return {
            a: 'aaa',
            b: 'bbb',
            c: 'ccc'
        }
    },
    methods: {
        getA() {
            return this.a
        },
        getB() {
            return this.b
        },
        getC() {
            return this.c
        }
    }
}
</script>
```
**Level2:**
```vue
<template>
    <p>Level2</p>
    <Level3
        :x="x"
        :y="y"
        :z="z"
        @getX="getX"
        @getY="getY"
        @getZ="getZ"
        v-bind="$attrs"
    ></Level3>
</template>

<script>
import Level3 from './Level3'

export default {
    name: 'Level2',
    components: { Level3 },
    props: ['a'],
    emits: ['getA'],
    data() {
        return {
            x: 'xxx',
            y: 'yyy',
            z: 'zzz'
        }
    },
    methods: {
        getX() {
            return this.x
        },
        getY() {
            return this.y
        },
        getZ() {
            return this.z
        }
    },
    created() {
        // console.log('level2', Object.keys(this.$attrs)) // 是 props 和 emits 后补
    },
}
</script>
```
**Level3:**
```vue
<template>
    <p>Level3</p>

    <HelloWorld msg="hello " ref="hello1"/>
</template>

<script>
import HelloWorld from '../HelloWorld'

export default {
    name: 'Level3',
    components: { HelloWorld },
    props: ['x'],
    emits: ['getX'],
    inheritAttrs: false,
    data() {
        return {
        }
    },
    created() {
        // console.log('level3', Object.keys(this.$attrs)) // 是 props 和 emits 后补
    },
    mounted() {
        // console.log(this.$parent.getX())
        console.log(this.$refs.hello1.name)
    },
}
</script>
```
- $parent
```vue
 mounted() {
        console.log(this.$parent.getX())
        <!-- console.log(this.$refs.hello1.name) -->
    },
```
- $refs
```vue
 mounted() {
        // console.log(this.$parent.getX())
        console.log(this.$refs.hello1.name)
    },
```
- provide/inject
**level1**
```vue
<template>
    <p>Level1: <input v-model="name"></p>

    <Level2></Level2>
</template>

<script>
import { computed } from 'vue'
import Level2 from './Level2'

export default {
    name: 'Level1',
    components: { Level2 },
    data() {
        return {
            name: '双越'
        }
    },
    // provide: {
    //     info: 'aaa'
    // }
    provide() {
        return {
            info: computed(() => this.name)
        }
    }
}
</script>
```
```vue
<template>
    <p>Level2 {{info.value}}</p>
    <Level3></Level3>
</template>

<script>
import Level3 from './Level3'

export default {
    name: 'Level2',
    components: { Level3 },
    inject: ['info']
}
</script>
```
**level3**
```vue
<template>
    <p>Level3 {{info.value}}</p>
</template>

<script>
export default {
    name: 'Level3',
    inject: ['info']
}
</script>
```
## vuex的mutation和action 
:::tip
- mutation:原子操作；必须同步代码
- action：可包含多个mutation；可包含异步代码
::: 

## js 严格模式有什么特点
:::tip
- 全局变量必须声明
- 禁止使用with
- 创建eval作用域
- 禁止this 指向window 严格模式下undefined
:::
![alt text](./assets/useStrict.png)


## js内存垃圾回收用什么算法？
:::tip
- 什么是垃圾回收？
  - 回收哪些函数被执行了，再也用不上了函数或变量
- 引用计数（之前） 
- 标记清除（现在）
- 闭包不是内存泄露，闭包的数据是不会被垃圾回收的
- 闭包内存泄露如何检测？场景有哪些
```js
 function fn1() {
        const a = 'aa'
        console.log(a)

        const obj = { x: 100 }
        console.log(obj)
    }
    fn1()

    function fn2() {
        const obj = { x: 100 }
        window.obj = obj
    }
    fn2()

    function getDataFns() {
        const data = {} // 闭包
        return {
            get(key) {
                return data[key]
            },
            set(key, value) {
                data[key] = value
            }
        }
    }
    const { get, set } = getDataFns()
    set('x', 100)
    get('x')

    // 对象被 a 引用
    let a = { x: 100 }
    let a1 = a
    a = 10
    a1 = null
     // 循环引用
    function fn3() {
        const obj1 = {}
        const obj2 = {}
        obj1.a = obj2
        obj2.a = obj1
    }
    fn3()
```
:::
## 内存泄漏的场景（vue为例）
:::tip
- 被全局变量、函数引用，组件销毁时未清除
```vue
<template>
  <p>Memory Leak Demo</p>
</template>

<script>
export default {
  name: "Memory Leak Demo",
  data() {
    return {
      arr: [10, 20, 30], // 数组 对象
    };
  },
  methods: {
    printArr() {
      console.log(this.arr);
    },
  },
  mounted() {
    window.arr = [1,2,3,4,4,5]
    // 自定义事件也是这样
  },
  // Vue2 - beforeDestroy
  beforeUnmount() {
    window.arr = null
  },
};
</script>
```
- 被全局事件、定时器引用，组件销毁时未清除
```vue
<template>
  <p>Memory Leak Demo</p>
</template>

<script>
export default {
  name: "Memory Leak Demo",
  data() {
    return {
      arr: [10, 20, 30], // 数组 对象
      intervalId:0
    };
  },
  methods: {
    printArr() {
      console.log(this.arr);
    },
  },
  mounted() {
    window.addEventListener("resize", this.printArr);
    this.intervalId = setInterval(()=>{
        console.log(this.arr)
    },100)
    // 自定义事件也是这样
  },
  // Vue2 - beforeDestroy
  beforeUnmount() {
    window.removeEventListener("resize", this.printArr);
    if(intervalId){
        clearInterVal(this.intervalId)
    }
  },
};
</script>

```
- 被自定义事件引用，组件销毁时未清除
```vue
<template>
  <p>receive custom event</p>
</template>

<script>
import event from '../utils/event.js'

export default {
  name: 'CustomEvent1',
  methods: {
    showMsg(msg) {
      console.log(msg)
    }
  },
  mounted() {
    event.on('showMsg', this.showMsg)
  },
  // Vue2.x beforeDestroy
  beforeUnmount() {
    event.off('showMsg', this.showMsg)
  },
}
</script>
```
:::
## 宏任务和微任务
:::tip
- 宏任务，如setTimeout setInterval网络请求
- 微任务，如promise async/await
- 微任务在下一轮DOM渲染之前执行，宏任务在之后执行
:::
![alt text](./assets/hw.png)
## nodejs异步
:::tip
- Nodejs同样使用ES语法，也是单线程，也需要异步
- 异步任务也分：宏任务+微任务
- 但是，它的宏任务和微任务，分不同类型，有不同优先级
:::
```js
// console.info('index')

console.info("start");
setImmediate(() => {
  console.info("setImmediate");
});
setTimeout(() => {
  console.info("timeout");
});
Promise.resolve().then(() => {
  console.info("promise then");
});
process.nextTick(() => {
  console.info("nextTick");
});
console.info("end");
//  start end nextTick promise then  timeout setImmediate
```
### Nodejs宏任务类型和优先级
```js
- Timers - setTimeout setInterval
- I/O callback - 处理网路、流 TCP 的错误回调
- Idle，prepare - 闲置状态 
- Pol轮询-执行pol川中的/O队列
- Check检查-存储setlmmediate回调
- Close callbacks-关闭回调，如socket..on('close')
```
### nodejs微任务类型和优先级
```js
- 包括：promise,async/await,process.nextTick
- 注意，process..nextTick优先级最高
```
![alt text](./assets/hw2.png)

### vdom真的很快吗？
:::tip
- 虚拟dom
- 用js对象 模拟DOM节点数据
- 有react最新推广使用
  - 组件话
  - 数据视图分离，数据驱动视图  
:::

