

# 工具函数

## Array Flatten 

- 写一个JS函数，实现数组扁平化，只减少一级嵌套
- 如输入`[1，[2，[3]，4]，输出[1,2，[3]，4]`

### 思路
:::tip
定义空数组arr=们。遍历当前数组
如果item非数组，则累加到arr
如果item是数组，则遍历之后累加到arr
:::
```js

/**
 * 数组扁平化，使用 push
 * @param arr arr
 */
export function flatten1(arr: any[]): any[] {
    const res: any[] = []

    arr.forEach(item => {
        if (Array.isArray(item)) {
            item.forEach(n => res.push(n))
        } else {
            res.push(item)
        }
    })

    return res
}

/**
 * 数组扁平化，使用 concat
 * @param arr arr
 */
export function flatten2(arr: any[]): any[] {
    let res: any[] = []

    arr.forEach(item => {
        res = res.concat(item)
    })

    return res
}

// // 功能测试
// const arr = [1, [2, [3], 4], 5]
// console.info( flatten2(arr) )

```
## Array Flatten 彻底拍平
> 写一个S函数，实现数组扁平化，减少所有嵌套的层级
> 如输入`[1，[2，[3]，4]，输出[1,2，，3,4]`

```js
/**
 * 数组深度扁平化，使用 push
 * @param arr arr
 */
export function flattenDeep1(arr: any[]): any[] {
    const res: any[] = []

    arr.forEach(item => {
        if (Array.isArray(item)) {
            const flatItem = flattenDeep1(item) // 递归
            flatItem.forEach(n => res.push(n))
        } else {
            res.push(item)
        }
    })

    return res
}

/**
 * 数组深度扁平化，使用 concat
 * @param arr arr
 */
export function flattenDeep2(arr: any[]): any[] {
    let res: any[] = []

    arr.forEach(item => {
        if (Array.isArray(item)) {
            const flatItem = flattenDeep2(item) // 递归
            res = res.concat(flatItem)
        } else {
            res = res.concat(item)
        }
    })

    return res
}

```

## getType函数-获取类型

```js
/**
 * 获取详细的数据类型
 * @param x x
 */
export function getType(x: any): string {
    const originType = Object.prototype.toString.call(x) // '[object String]'
    const spaceIndex = originType.indexOf(' ')
    const type = originType.slice(spaceIndex + 1, -1) // 'String'
    return type.toLowerCase() // 'string'
}

// // 功能测试
// console.info( getType(null) ) // 'null'
// console.info( getType(undefined) )
// console.info( getType(100) )
// console.info( getType('abc') )
// console.info( getType(true) )
// console.info( getType(Symbol()) )
// console.info( getType({}) )
// console.info( getType([]) )
// console.info( getType(() => {}) )
```

## new 一个对象发生了什么？请手写代码表示 

> class 是function的语法糖

:::tip
- 创建一个空对象oj,继承构造函数的原型
- 执行构造函数（将obj作为this）
- 返回obj
:::

```js
class Foo {
    name:string;
    city:string;
    constructor(name){
        this.name = name;
        this.city = 'bj'
    }
    getName(){
        return this.name
    }
}
const f = new Foo('ljh')
f.getName()
```
**new**
```js
export function customNew<T>(constructor: Function, ...args: any[]): T {
    // 1. 创建一个空对象，继承 constructor 的原型
    const obj = Object.create(constructor.prototype);
    // 2. 将 obj 作为 this ，执行 constructor ，传入参数
    constructor.apply(obj, args);
    // 3. 返回 obj
    return obj;
}
```
## {}和Object.prototype 区别
:::tip
- {}创建空对象，原型指向Object.prototype
- Object.create创建空对象，原型指向传入的参数
:::

## 遍历dom树