---
sidebarDepth: 10
---

# 前端技术选型



## CSS 
### CSS 函数 

#### 数学计算函数

```css
.element {
  /* calc() - 基础数学计算 */
  width: calc(100% - 20px);
  
  /* min() - 取最小值 */
  width: min(50%, 500px);
  
  /* max() - 取最大值 */
  width: max(50%, 300px);
  
  /* clamp() - 值的范围限定 (MIN, VAL, MAX) */
  width: clamp(200px, 50%, 800px);
}
```

#### 颜色函数

```css
.element {
  /* RGB颜色 */
  color: rgb(255, 0, 0);
  color: rgba(255, 0, 0, 0.5);
  
  /* HSL颜色 */
  color: hsl(0, 100%, 50%);
  color: hsla(0, 100%, 50%, 0.5);
  
  /* 颜色混合 */
  background: color-mix(in srgb, #34c9eb 25%, white);
  
  /* 相对颜色改变 */
  color: color-contrast(white);
  
  /* 当前颜色 */
  border-color: currentColor;
}
```

#### 自定义属性函数

```css
.element {
  /* var() - 使用CSS变量 */
  color: var(--main-color, #000);
  
  /* env() - 环境变量 */
  padding-bottom: env(safe-area-inset-bottom);
  
  /* 属性引用 */
  content: attr(data-label);
}
```

#### 变换和过滤函数

```css
.element {
  /* 变换函数 */
  transform: translate(50px, 100px);
  transform: rotate(45deg);
  transform: scale(1.5);
  transform: skew(10deg);
  transform: matrix(1, 0, 0, 1, 0, 0);
  
  /* 过滤函数 */
  filter: blur(5px);
  filter: brightness(150%);
  filter: contrast(200%);
  filter: grayscale(50%);
  filter: hue-rotate(90deg);
  filter: invert(75%);
  filter: opacity(50%);
  filter: saturate(30%);
  filter: sepia(60%);
}
```

####  渐变函数

```css
.element {
  /* 线性渐变 */
  background: linear-gradient(to right, red, blue);
  
  /* 径向渐变 */
  background: radial-gradient(circle, red, blue);
  
  /* 圆锥渐变 */
  background: conic-gradient(from 45deg, red, blue);
  
  /* 重复渐变 */
  background: repeating-linear-gradient(45deg, red 0%, blue 10%);
}
```

#### 网格和布局函数

```css
.container {
  /* repeat() */
  grid-template-columns: repeat(3, 1fr);
  
  /* minmax() */
  grid-template-columns: minmax(100px, 1fr);
  
  /* fit-content() */
  width: fit-content(300px);
}
```

#### 图形函数

```css
.element {
  /* clip-path */
  clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
  
  /* path() */
  clip-path: path('M0,0 L100,0 L100,100 L0,100 Z');
  
  /* shape-outside */
  shape-outside: circle(50%);
}
```

#### 滤镜和混合模式

```css
.element {
  /* 背景混合 */
  background-blend-mode: multiply;
  
  /* 混合模式 */
  mix-blend-mode: overlay;
  
  /* 高级滤镜 */
  backdrop-filter: blur(10px) brightness(80%);
}
```

#### 动画和时间函数


```css
.element {
  /* 步进函数 */
  transition-timing-function: steps(4, end);
  
  /* 贝塞尔曲线 */
  animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}
```

### 视觉效果函数

```css
.element {
  /* 投影 */
  box-shadow: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
  
  /* 混合 */
  background-image: cross-fade(url(image1.jpg), url(image2.jpg), 50%);
}
```

#### CSS 伪类选择器
##### 基础结构性伪类

```css
/* 第一个和最后一个 */
:first-child     /* 第一个子元素 */
:last-child      /* 最后一个子元素 */
:only-child      /* 唯一的子元素 */
:first-of-type   /* 第一个特定类型的元素 */
:last-of-type    /* 最后一个特定类型的元素 */
:only-of-type    /* 唯一的特定类型元素 */

/* 示例 */
li:first-child {
  font-weight: bold;
}
p:first-of-type {
  font-size: 1.2em;
}
```

#### 位置相关伪类

```css
/* nth选择器 */
:nth-child(n)        /* 第n个子元素 */
:nth-last-child(n)   /* 倒数第n个子元素 */
:nth-of-type(n)      /* 第n个特定类型元素 */
:nth-last-of-type(n) /* 倒数第n个特定类型元素 */

/* 常用公式 */
:nth-child(odd)      /* 奇数位置 */
:nth-child(even)     /* 偶数位置 */
:nth-child(3n)       /* 每3个 */
:nth-child(3n+1)     /* 每3个后的第1个 */

/* 示例 */
tr:nth-child(even) {
  background-color: #f2f2f2;
}

li:nth-child(3n+1) {
  margin-left: 0;
}
```

#### 状态相关伪类

```css
/* 表单状态 */
:disabled    /* 禁用状态 */
:enabled     /* 可用状态 */
:checked     /* 选中状态 */
:required    /* 必填项 */
:optional    /* 选填项 */
:valid       /* 验证通过 */
:invalid     /* 验证失败 */
:in-range    /* 在范围内 */
:out-of-range/* 超出范围 */

/* 链接状态 */
:link        /* 未访问链接 */
:visited     /* 已访问链接 */
:hover       /* 鼠标悬停 */
:active      /* 激活状态 */
:focus       /* 获得焦点 */
:focus-within/* 子元素获得焦点 */
:focus-visible/* 键盘焦点可见 */

/* 示例 */
input:invalid {
  border-color: red;
}

button:hover {
  background-color: #0056b3;
}
```

#### 内容相关伪类

```css
:empty              /* 空元素 */
:target             /* 当前锚点目标 */
:lang(language)     /* 特定语言 */
:not(selector)      /* 否定选择器 */
:is(selector)       /* 匹配任意选择器 */
:where(selector)    /* 零优先级的组合 */
:has(selector)      /* 包含特定元素 */

/* 示例 */
p:empty {
  display: none;
}

:not(.active) {
  opacity: 0.5;
}
```

#### 复杂选择器组合

```css
/* 多条件组合 */
input:enabled:hover {
  border-color: blue;
}

/* 否定组合 */
.item:not(:first-child):not(:last-child) {
  margin: 0 10px;
}

/* 状态组合 */
.button:hover:not(:disabled) {
  transform: scale(1.05);
}
```

### Less/Sass

```text
优点:
- 提供变量、嵌套、混合、函数等编程能力
- 代码复用性强,维护方便
- 兼容普通 CSS,学习成本较低

缺点:
- 需要编译步骤,增加构建时间
- 代码可能会冗余
- 运行时无法动态修改变量
```

### css module

```text
优点:
- 局部作用域,解决命名冲突
- 与组件化开发契合
- 编译时生成唯一类名,无运行时开销

缺点:
- 不能动态修改样式
- 需要构建工具支持
- 全局样式需要特殊处理 
没有对应的函数 和方法 
```

### css in js
 
```text

优点:
- 完全组件化,样式跟随组件
- 支持动态样式计算
- 运行时生成样式,更灵活

缺点:
- 运行时开销较大
- 增加打包体积
- 部分方案需要额外学习成本

```
#### Styled Components

```js
// 1. 基础用法
import styled from 'styled-components';

const Button = styled.button`
  background: ${props => props.primary ? 'blue' : 'white'};
  color: ${props => props.primary ? 'white' : 'blue'};
  padding: 10px 20px;
`;

// 使用
<Button primary>Click me</Button>
```

#### emotion

```js
import { css } from '@emotion/css'

const style = css`
  background-color: hotpink;
  &:hover {
    color: white;
  }
`

// 使用
<div className={style}>This has a hotpink background.</div>

```

#### [Styletron](https://claude.ai/chat/9b833c02-549a-41df-a7c9-26e58e865c24)

```js
Styletron 是一个高性能的 CSS-in-JS 解决方案，具有以下主要特点：

原子化 CSS

    自动将样式拆分为最小单位
    实现最大程度的样式复用
    减少生成的 CSS 大小


性能优势

    虚拟 CSS 引擎
    自动去重
    按需加载样式

```

### js in css 

> 既想css 有js 的能力 ，又想css样式分离,衍生了js in css
> JS in CSS 指的是在 CSS 中直接使用 JavaScript 的能力，主要通过 CSS Houdini API 实现。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      /* 定义CSS变量 */
      :root {
        --zhijia: "Hello CSS Variable";
      }

      /* 使用CSS变量 */
      a::before {
        content: var(--zhijia);
      }

      /* 基础样式 */
      a {
        position: relative;
        margin: 20px;
      }
    </style>
  </head>
  <body>
    <a>这个css in js</a>

    <!-- 如果你想要使用JavaScript来动态修改CSS变量 -->
    <script>
      // 方法1：直接设置CSS变量
      //   document.documentElement.style.setProperty("--zhijia", '"Updated Value"');

      // 方法2：通过JavaScript函数动态更新内容
      //   function updateContent() {
      //     const root = document.documentElement;
      //     root.style.setProperty("--zhijia", '"Dynamic Content"');
      //   }
    </script>
  </body>
</html>

```

#### Houdini API 介绍 

![alt text](./assets/houdini_1.png)

![alt text](./assets/houdini_2.png)

- CSS Parser API

```css
// CSS 解析器 API
主要功能：
- 允许开发者扩展 CSS 词法分析器
- 可以解析新的CSS语法结构
- 支持新的媒体查询规则、@extends、@apply等

实例：
// 注册新的CSS自定义属性
CSS.registerProperty({
  name: '--my-color',
  syntax: '<color>',
  inherits: false,
  initialValue: '#c0ffee'
});

```

- CSS Layout API

```js
// 布局 API
主要功能：
- 允许开发者创建自定义布局模块
- 类似于 display: flex 或 display: grid
- 可以实现完全自定义的布局算法

示例：
registerLayout('masonry', class {
  static get inputProperties() {
    return ['width', 'height'];
  }
  
  async layout(children, edges, constraints, styleMap) {
    // 自定义布局逻辑
    return {
      childrenSizes: sizes,
      autoBlockSize: height
    };
  }
});
```

- CSS Paint API

```js
// 绘制 API
主要功能：
- 提供类似Canvas的绘制能力
- 可以创建自定义背景、边框等视觉效果
- 通过registerPaint注册自定义绘制方法

示例：
registerPaint('circlePattern', class {
  paint(ctx, size, properties) {
    // 使用Canvas API进行绘制
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(size.width/2, size.height/2, 50, 0, 2 * Math.PI);
    ctx.fill();
  }
});
```

- CSS Worklets

```js
// 工作线程
主要功能：
- 允许在渲染流程中执行JavaScript
- 可以创建高性能的动画和效果
- 支持自定义绘制和布局操作

使用方式：
// 加载绘制worklet
CSS.paintWorklet.addModule('my-paint-worklet.js');

// 加载布局worklet
CSS.layoutWorklet.addModule('my-layout-worklet.js');
```


####  css-doodle

```js
<css-doodle>
  :doodle {
    @grid: 5x5;    /* 创建5x5的网格 */
  }
  background: @pick(#ff0000, #00ff00, #0000ff);  /* 随机选择颜色 */
</css-doodle>
```

### type om object 

- 主要概念和类型：
    - CSSStyleValue：所有 CSS 值的基类

    - CSSKeywordValue: 关键字值（如 'auto', 'none'）

    - CSSUnitValue: 带单位的数值（如 '42px'）

    - CSSMathValue: 计算表达式

    - CSSTransformValue: 变换值

    - CSSImageValue: 图片值


```js
// 1. 基础属性访问和设置
const element = document.querySelector('.example');

// 传统方式
element.style.opacity = '0.5';
console.log(element.style.opacity); // "0.5" (字符串)

// Typed OM 方式
element.attributeStyleMap.set('opacity', 0.5);
console.log(element.attributeStyleMap.get('opacity').value); // 0.5 (数字)

// 2. 数值计算和单位转换
// 创建CSS数值
const width = CSS.px(42);
const height = CSS.vw(50);
const margin = CSS.rem(1.2);

// 数值运算
const calc = CSS.px(100).add(CSS.vw(50));
console.log(calc.toString()); // "calc(100px + 50vw)"

// 3. 使用 CSSStyleValue 创建样式
const color = new CSSKeywordValue('red');
const padding = new CSSUnitValue(5, 'px');
const transform = new CSSTransformValue([
  new CSSTranslate(CSS.px(100), CSS.px(200))
]);

// 4. 批量设置样式
element.attributeStyleMap.set('width', CSS.px(200));
element.attributeStyleMap.set('height', CSS.px(100));
element.attributeStyleMap.set('background-color', new CSSKeywordValue('blue'));

// 5. 读取计算样式
const computedStyles = document.querySelector('.example').computedStyleMap();
console.log(computedStyles.get('width').value); // 获取计算后的宽度值
console.log(computedStyles.get('color').toString()); // 获取计算后的颜色值

// 6. 处理复杂值
// Transform 示例
const transformValue = new CSSTransformValue([
  new CSSRotate(CSS.deg(45)),
  new CSSScale(1.5, 1.5),
  new CSSTranslate(CSS.px(100), CSS.px(0))
]);
element.attributeStyleMap.set('transform', transformValue);

// 7. 自定义属性处理
CSS.registerProperty({
  name: '--my-color',
  syntax: '<color>',
  inherits: false,
  initialValue: '#c0ffee'
});

// 8. 数值验证
try {
  element.attributeStyleMap.set('opacity', CSS.number(2)); // 抛出错误，opacity 必须在 0-1 之间
} catch (e) {
  console.error('Invalid opacity value');
}
```

### 原子css 

#### Css Next

> CSS Next (现在也叫 PostCSS Preset Env)，这是一个允许你使用未来 CSS 特性的工具。

